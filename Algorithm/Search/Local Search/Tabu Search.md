---
상위 개념: "[[Local Search]]"
---
# Tabu Search
Tabu Search는 기억공간에 상태를 저장하여 특정 탐색 공간에 국한되지 않도록 강제하는 탐색 알고리즘이다. 최근에 조사한 솔루션은 저장되며, 이들은 '타부' 솔루션으로 취급되고 다음 솔루션을 선택하는 과정에서 제외된다.

Stochastic HC와 SA는 확률적 방법론을 통해 Local Optima 문제를 해결하기에, 결과는 각각의 실행마다 바뀐다. 반면 Tabu Search는 결정적(deterministic) 탐색 방법이다.

## Recency-based memory
최근 기반 메모리 방식은 지난 몇 가지 행동들을 기록함으로써 동작한다.

8개의 도시를 방문해야하는 TSP 문제를 예로 든다. 변환 방식은 2개의 도시를 스왑하는 것으로 한다.

| city | 1   | 2   | 3   | 4     | 5     | 6     | 7     | 8     |
| ---- | --- | --- | --- | ----- | ----- | ----- | ----- | ----- |
| 1    | 0   | 0   | 0   | **1** | 0     | 0     | 0     | 0     |
| 2    |     | 0   | 0   | 0     | 0     | **5** | 0     | 0     |
| 3    |     |     | 0   | 0     | 0     | 0     | **4** | 0     |
| 4    |     |     |     | 0     | **3** | 0     | 0     | 0     |
| 5    |     |     |     |       | 0     | 0     | 0     | **2** |
| 6    |     |     |     |       |       | 0     | 0     | 0     |
| 7    |     |     |     |       |       |       | 0     | 0     |
| 8    |     |     |     |       |       |       |       | 0     |
map\[i]\[j]의 값 v에 대해서 '도시 i와 j는 v 번째 이동에서 스왑되었다.'라는 것을 의미한다. map\[2]\[6]이 5이므로, 가장 최근의 변환이 두 도시를 변경하는 것이었음을 알 수 있다. 로직에 따라 달라지겠지만 '추후 5번째 변환(10번째 변환) 까지는 2와 6을 바꾸지 않는다.'라는 규칙을 적용할 수 있다.

## Frequency-based memory
빈도 기반 메모리 방식은 지난 행동들의 빈도를 기록함으로써 동작한다.

| city | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   |
| ---- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1    | 0   | 0   | 2   | 3   | 3   | 0   | 1   | 1   |
| 2    |     | 0   | 2   | 1   | 3   | 1   | 1   | 0   |
| 3    |     |     | 0   | 2   | 3   | 3   | 4   | 0   |
| 4    |     |     |     | 0   | 1   | 1   | 2   | 0   |
| 5    |     |     |     |     | 0   | 4   | 2   | 1   |
| 6    |     |     |     |     |     | 0   | 3   | 1   |
| 7    |     |     |     |     |     |     | 0   | 6   |
| 8    |     |     |     |     |     |     |     | 0   |
map\[i]\[j] = v에 대하여 '도시 i와 도시 j는 v회 변환되었다.'라는 것을 의미한다. 이를 통해 가장 변경이 덜 발생한 도시들을 우선적으로 변환에 참여시킬 수 있다.