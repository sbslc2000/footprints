---
상위 개념: "[[Algorithm]]"
---
# 동적 계획법
재귀적 해법을 사용하면 심한 중복 호출이 일어나 효율이 떨어지는 경우가 발생한다.

다음은 n번째 피보나치 수를 반환하는 재귀함수이다.
![](https://i.imgur.com/PmBh3zD.png)
위 코드의 호출 트리는 아래와 같다.
![](https://i.imgur.com/Ob6W3GY.png)

재귀적 구현으로 인해 fib(2)가 총 8번 호출되는 것을 확인할 수 있다. 동적 프로그래밍은 이러한 중복호출을 없애서 성능을 높이는 방법론이자 알고리즘이다.

동적 프로그래밍은 다음과 같은 구조를 갖는 문제의 해법으로 사용될 수 있다.

- **최적 부분구조_Optimal Substructure_**
최적 부분구조란 큰 문제를 해결하는데에 작은 문제의 결과가 포함되는 구조를 의미한다. 최적 부분구조가 존재하는 문제는 재귀적 방식을 통해 관계 중심으로 파악하고 문제를 간명하게 볼 수 있다.

- **재귀호출 시 중복_Overlapping Recursive Calls_**
최적 부분구조를 해결하기 위해 재귀적 해법을 사용할 때 동일한 재귀함수가 중복되는 상황을 의미한다.

피보나치 수열 문제는 f(n) 을 구하기 위해 f(n-1)과 f(n-2) 의 결과를 사용하고, 호출시 중복이 말생하기 때문에 동적 프로그래밍을 사용하기 알맞은 예제이다.

![](https://i.imgur.com/778P5yz.png)
위 예제는 피보나치 문제를 동적 프로그래밍을 적용하여 해결한 결과이다. f(n)을 구하기 위해서는 f(n-1)과 f(n-2)를 알아야하는데, 재귀적 해법에서는 이를 중복호출하게 된다. 이 중복호출을 막기 위해서 가장 base가 되는 f(1)과 f(2)를 1로 놓아주고, f(3) 부터는 반복문을 통해 구한다. f(3)을 구하는 시점에는 f(2)와 f(1)이 구해져 있을 것이고, 더 나아가 f(n)을 구하는 시점에서 f(n-1)과 f(n-2)는 구해져 있을 것이다. 각각의 수를 구하는데에는 선형적으로 동작하므로 중복호출이 발생하지 않는다.

![](https://i.imgur.com/P3gXj02.png)
재귀적인 구조를 유지하면서도 동적 계획법을 사용할 수 있다. 이 방법에서는 기존의 계산 결과를 저장해둘 공간이 필요하다. 각 계산 결과는 deterministic 하므로, 한번 계산된 결과를 저장해두고 이후부터는 계산 과정을 스킵하고 이미 저장해둔 결과를 반환할 수 있다. 이러한 기법을 메모이제이션*Memoization*이라고 한다.