---
상위 개념: "[[Shortest Path Algorithm]]"
---
# Bellman-Ford Algorithm
벨만-포드 알고리즘은 간선을 최대 1개 사용하는 최단경로, 간선을 최대 2개 사용하는 최단 경로,… 이런식으로 간선을 최대 n-1개 사용하는 최단경로까지 구해나간다.

## Pseudo Code
![](https://i.imgur.com/ndNrZHa.png)
첫번째 for문으로 최단거리를 구하고 난 뒤 두번재 for문에서 음의 싸이클 존재 여부를 확인한다.
![](https://i.imgur.com/ZoutZ9w.png)
첫번째 for문이 돌아간 이후고, 음의 싸이클이 존재하지 않는다면, 모든 d[u] + w[u,v] 는 d[v]보다 같거나(최단경로에 관여한 경우) 크다(최단경로에 관여하지 못한경우). 이 경우에 만약 음수가 나온다면 음수 싸이클을 감지한 것이 되어 알고리즘이 수행될 수 없는 환경임을 알린다.

## 예시
![](https://i.imgur.com/TjBAEQS.png)
각각의 iteration이 끝난 후 정점에 기록된 값은 i개의 간선을 사용했을 때 해당 정점까지 가는 최소비용이다. 이는 i개 보다 적은 수의 간선을 사용했을 때의 값일 수도 있다.

예를 들어 iteration 2 에서 시작 정점에서 (10) 정점으로 가는 방식은 8 →10 간선을 타고 18의 비용으로 가는 것과 9→1 간선을 타고 10의 비용으로 가는 방법이 있다. iteration 2에서는 두 값이 경쟁하여 10이 기록된다.

이후 iteration 3에서는 세 개의 간선을 통해 갈 수 있는 최소비용이 업데이트 되는데, 위의 정점은 3개의 간선을 사용했을 때는 9→-15→10 의 경로를 따라 4의 비용으로 갈 수 있다. 따라서 위에서 기록됐던 10은 4로 덮어씌워진다.
![](https://i.imgur.com/yZ8QE3R.png)
