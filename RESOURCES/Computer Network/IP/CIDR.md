# Classless Interdomain Routing
서브네팅에는 이를 보완하는 개념이 있는데, 이를 슈퍼네팅*Supernetting*이라고 부르기도 하지만, 더 일반적으로는 CIDR이라고 부릅니다. CIDR은 서브네팅의 아이디어를 논리적으로 확장하여 **주소 클래스를 완전히 제거**합니다. 그렇다면 왜 서브네팅만으로는 충분하지 않을까요? 본질적으로 서브네팅은 하나의 클래스 주소를 여러 서브넷으로 나누는 데 그치지만, CIDR은 여러 클래스 주소를 하나의 “슈퍼넷”으로 결합할 수 있게 해줍니다. 이는 위에서 언급한 주소 공간 비효율성을 더욱 효과적으로 해결하며, 동시에 라우팅 시스템의 과부하를 방지합니다.

주소 공간 효율성과 라우팅 시스템의 확장성 문제의 연관성을 이해하기 위해, 256개의 호스트를 가진 가상의 회사 네트워크를 예로 들어보겠습니다. 이 회사는 클래스 C 주소(최대 255개 호스트 지원)로는 부족하므로 클래스 B 주소를 할당받아야 한다고 가정해봅시다. 하지만, 클래스 B 주소는 65,535개의 호스트를 지원할 수 있는 주소 공간을 차지하는데, 이를 256개의 호스트를 위해 사용하는 것은 효율성이 단지 256/65,535 = 0.39%에 불과합니다. 서브네팅이 주소를 더 세밀하게 할당하는 데 도움을 줄 수는 있지만, 255개 이상의 호스트를 가지거나 그렇게 확장될 가능성이 있는 조직이 클래스 B 주소를 원한다는 사실은 바뀌지 않습니다.

이 문제를 해결하는 첫 번째 방법은, 클래스 B 주소를 요청하는 조직에게 그들이 64,000개에 가까운 주소가 필요하다는 증거를 제공하지 못하면 할당을 거부하고, 대신 클래스 C 주소를 필요한 만큼 제공하는 것입니다. 이제 우리는 256개 주소 단위로 주소 공간을 할당하게 되므로, 조직의 크기에 맞게 소비되는 주소 공간을 더 정확하게 조정할 수 있습니다. 256개 이상의 호스트를 가진 조직의 경우, 최소한 50% 이상의 주소 활용률을 보장할 수 있으며, 일반적으로 그보다 훨씬 높은 효율성을 기대할 수 있습니다.

> 클래스 B 네트워크 번호를 요청할 정당한 이유가 있더라도, 신경 쓰지 않는 것이 좋습니다. 클래스 B 주소는 이미 모두 할당되었습니다.

그러나 이 해결책에는 최소한 동일한 수준으로 심각한 문제가 하나 더 있습니다. 그것은 바로 **라우터의 과도한 저장 요구사항**입니다. 예를 들어, 단일 사이트에 16개의 클래스 C 네트워크 번호가 할당되었다고 가정해봅시다. 이 경우, 모든 인터넷 백본 라우터는 해당 사이트로 패킷을 전달하기 위해 **라우팅 테이블에 16개의 항목**을 유지해야 합니다. 이는 해당 네트워크들로 가는 경로가 모두 동일하더라도 마찬가지입니다.

만약 해당 사이트에 클래스 B 주소를 할당했다면, 동일한 라우팅 정보는 **하나의 테이블 항목**에 저장될 수 있었을 것입니다. 하지만 이 경우 주소 할당 효율성은 단지  6 \times 255 / 65,536 = 6.2\% 에 불과하게 됩니다.