# 라빈-카프 알고리즘
라빈-카프 알고리즘은 문자열 패턴을 수치로 바꾸어 비교하는 알고리즘이다.

## Numerical Representation
가능한 문자 집합의 크기에 따라 진수가 결정된다. 만약 ASCII 문서라면 128진수가 될 것이다. 여기서는 설명의 간료함을 위해 {a,b,c,d,e} 5개의 문자만이 존재하는 경우로 제한한다.

5개의 문자가 사용되는 경우 a, b, c, d, e 를 각각 0, 1, 2, 3, 4에 대응시킨다. 이를 통해 문자열 ‘cad’는 수치화를 통해 $2_5^2+0_5^1+3*5^0 = 53$ 로 만들 수 있다. 이는 일종의 해싱이다.

수치비교를 위해 전체 문자열의 각 조각들을 전부 계산할 필요는 없다. 비교 대상인 문자열은 그들간의 중복 관계가 존재하기 때문이다.문자열 조각간에는 다음과 같은 공식이 성립한다.

$a_i$ : i번째부터 시작하는 전체 문자열의 일부
d : 문자 집합의 총 개수
A : 전체 문자열
n : 패턴 문자열의 길이

$a_i = d(a_{i-1} - d^{n-1}A[i-1]) + A[i+m-1]$

$d^{n-1}$의 경우 반복되어 사용되므로 한번만 계산해 두면 된다. 따라서 $a_{i-1}$을 알고 있으면, $a_i$를 계산하기 위해서는 상수시간만이 필요하다.

![](https://i.imgur.com/WW2aOXR.png)

## Pseudo Code
![](https://i.imgur.com/65iV0X5.png)
원본 문자열에서 인덱스를 올려가며 상수시간의 수치화를 한뒤 패턴과 비교하므로 전체 소요시간은 전체 문자열의 길이와 비례한다.

## 단점
문자집합의 크기와 패턴문자열의 크기에 따라 수치화된 값의 크기가 매우 커져 컴퓨터 레지스터의 용량을 초과하게 될 수 있다. 이 경우 오버플로우가 발생한다는 문제가 생긴다.

물론 오버플로우가 발생하더라도, 해당 값은 고유해서 문제가 없기도 하지만, 이를 해결하기 위해서 나머지 연산을 사용하여 값의 최대를 제한할 수 있다. 나머지 연산의 피연산자는 충분히 큰 소수를 사용한다.