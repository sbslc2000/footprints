# 프림 알고리즘
프림 알고리즘은 탐욕 알고리즘*Greedy Algorithm*의 일종이며, 탐욕 알고리즘으로 최적해를 보장하는 드문 예이다.

프림 알고리즘은 집합 S를 공집합에서 시작하여 모든 정점을 포함할 때까지 키워 나간다. 정점을 하나 더할 때마다 간선이 하나씩 확정된다.

## 예시
![](https://i.imgur.com/stzqpKC.png)
먼저 공집합 S로 시작한다. 모든 정점은 최초의 거리가 $\infty$ 로 초기화 된다.

S에 최초 정점 0을 포함시키고, 거리를 0으로 만든다. 이 최초 정점의 선택에 따라 최소신장트리의 구성이 바뀔 수 있다. 트리의 구성은 바뀔 수 있지만, 가중치의 합은 동일할 것이다.

(b)에서는 최초 정점 0으로부터 인접한 정점의 거리를 각 정점에 기록해둔다. 각 정점에 기록된 비용은 집합 S에 있는 정점과 연결하는데 드는 최소비용을 의미한다.

(c)에서는 S 에서 연결될 수 있는 정점 중 비용이 가장 낮은 것(8)을 선택하여 S에 포함시킨다. 이때 새로운 정점에 인접한 정점의 거리를 해당 정점에 기록해준다.

(d)에서 (9)를 선택하고, 연결된 정점의 거리를 기록해준다. (d) 에서 정점을 선택함으로써 기존에 S로부터 거리가 10이었던 정점의 최소거리가 5로 바뀌었다. 가운데 정점이 S에 포함됨으로써 S로부터 그곳으로 가는 새로운 더 짧은 루트가 개척된 것이다. 이렇게 각각의 정점은 S로 편입되는 정점에 따라 새롭게 변화되는 S로부터의 최소 비용거리를 기록하게 된다.

$\infty$ → 10 과 같이 변경되는 경우는 이 정점이 최초로 집합 S에 연결할 수 있게 되었을 때이다. 10 → 5 와 같이 변경되는 경우는 이미 연결은 할 수 있는 상황이었지만 더 좋은 연결방법이 발견되었을 때이다. 이렇게 값이 바뀌는 것을 **이완Relaxation**이라고 한다.

![](https://i.imgur.com/iODdp4P.png)
(h) 까지의 과정을 통해 모든 정점이 집합 S에 포함됨으로써 알고리즘은 종료된다. 이때 정점들을 집합 S로 넣는데 기여한 간선들만 남기면 최소신장트리를 만들 수 있다.

## Pseudo Code
![](https://i.imgur.com/WlS8FtI.png)
Pseudo Code에서는 while 문 내부에 for문이 있는데 이것이 시간복잡도에 영향을 미치지 않을지 고민이 될 수도 있다. 사실 내부의 for문은 총 2\*E번 수행된다. 각각의 정점은 한번 씩만 방문될 것이며, 각각의 정점을 방문했을 때 연결되어있는 간선을 한번씩 처리한다고 하면 하나의 간선에 대해 서로 다른 방향 관점에서 2번씩만 처리되기 때문이다. 2\*E 번은 while문에 포함된 `extractMin()`에 비해 작으므로 점근적 분석법에서는 고려하지 않아도 좋다.

알고리즘은 `extractMin()`의 시간복잡도에 영향을 받는다. `extractMin()`이 간선을 for문 등으로 선형적으로 조사하여 가장 작은 값을 찾는 경우 해당 부분의 시간복잡도는 $O(V)$이기 때문에, V회 수행되는 while문과 함께 처리되었을 때 전체 시간복잡도는 $O(V^2)$ 를 갖는다.

만약 `extractMin()` 을 힙으로 구현하면 가장 작은 값을 찾기 위해 $O(\log V)$의 시간이 걸린다. 이 경우 while 이 V번 반복되므로 관련된 비용은 $O(V\log V)$이다. 그런데 d[]에 관련된 값을 반영하여 조정하는데에도 $O(\log V)$시간이 소요되고, 이것은 최대 E번 발생할 수 있으므로 최종적인 알고리즘의 수행시간은 $O(E\log V)$가 된다.