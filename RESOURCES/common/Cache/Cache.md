# Cache
캐시는 공간 비용을 사용하여 읽기 부하를 줄이기 위한 기술이다.

## 캐시는 왜 효과적인가?
### Memory Read vs Disk Read
일반적으로 메모리와 디스크의 속도 차는 10만~100만배 정도의 차이가 난다. 따라서 데이터를 여러번 조회할 때에는 매번 디스크에 접근하기 보다는 최초에 가져온 값을 메모리에 저장해서 조회할 때에 읽기 부하를 효과적으로 줄일 수 있다.

### Temporal Locality & Spatial Locality
프로그램은 특정한 시간동안 메모리의 일부만을 접근하는 경향이 있다.

* **Temporal Locality** : 최근에 접근한 아이템에 또 접근하는 경향
* **Spatial Locality** : 최근에 접근한 아이템의 근처 아이템에 접근하는 경향

이는 애플리케이션 레벨에서도 동일하다.

게시판을 예시로 든다면, 사용자들은 보통 최근 게시물을 많이 조회한다. 이는 Temporal Locality를 만족하는 예이다. 또한 사용자는 일반적으로 게시판을 페이지를 넘겨가며 읽을만한 글을 찾게 된다. 이는 Spatial Locality를 만족하는 예이다. 따라서 이 경우 캐시를 적절히 사용하면 Disk Read를 효과적으로 줄이고 전체 시스템의 부하를 개선할 수 있다.

### Cost
![](https://i.imgur.com/h0ChnAp.png)

저장소 공간은 입출력이 빠를수록 비싸며, 느릴수록 저렴하다. 이런 특징 때문에 하나의 컴퓨팅 시스템은 가격을 효율적으로 사용하려면 적은 공간의 SRAM과 많은 공간의 DISK를 놓고, 그 사이의 데이터 전송을 최소화하며 작업을 할 때 전체 비용과 성능 간 최적화를 이루어낼 수 있다. 이를 효과적으로 지원하는 기술 중 하나가 캐시이다.

## Terminologies
* **Cache Hit** : 캐시에 데이터가 존재하여 캐시에서 데이터를 읽어온 경우
* **Cache Miss** : 캐시에서 데이터를 찾지 못하고 원본 데이터에서 가져온 경우
* **Read-Through** : 캐시를 먼저 확인하고 없으면 원본 데이터에서 가져오는 정책 -> 캐시가 없을 때는 네트워크 홉이 추가되므로 오히려 시스템이 느려질 수 있다.
* **Write-Through** : 캐시 값의 변경이 생겼을 때, 캐시와 원본 데이터를 함께 변경한다.
* **Write-Back** : Dirty Bit를 유지해서, 캐시 값의 변경은 캐시에서 유지하고 캐시가 축출될 때 원본 데이터를 변경한다.

## 무엇을 담아야 하는가?
캐시에 담아야하는 대상은 다음과 같다.
* 연산이 오래 걸리는 결과
* I/O가 오래 걸리는 데이터
* 자주 변경되지 않고 자주 접근하는 데이터

## Invalidation
캐시 데이터는 적절한 만료 시기를 설정하여 데이터를 무효화할 필요가 있다.
만약 만료 시간이 너무 길다면, 오래된 데이터를 보여주어 정확성에 문제가 발생할 수 있고, 만료 시간이 너무 짧다면 Cache Miss로 인한 성능 저하가 발생할 수 있다.

## Consistency
일관성은 캐시와 원본 데이터의 동기화 상태를 의미한다. 일관성을 위해서는 원본 데이터 수정 시 캐시를 업데이트 해야한다.

### 동시성 이슈
캐시를 업데이트 하는 과정에서는 동시성 이슈가 발생할 수 있다. A 쓰레드에서 발생한 변경사항을 캐시에 업데이트하려는 찰나 B 쓰레드에서 발생한 변경사항이 캐시에 업데이트가 된다면 이후 값은 덮어씌워지고 잘못된 데이터가 담겨 있을 수 있다.

이를 해결하기 위한 일반적인 방법은 캐시를 업데이트하는 방식이 아닌 **캐시를 삭제**하는 방법이다. 이는 Cache Miss를 발생시킬 수 있으나 일관성을 유지할 수 있다.

## Eviction : 축출
캐시 공간이 부족할 때 잘 사용되지 않는 캐시를 축출하는 것이 필요하다. 
LRU와 같은 캐시 축출 정책을 가지고 캐시의 크기를 유지한다.

## Multi-level Cache
![](https://i.imgur.com/jaEua0h.png)
캐시는 여러 레이어를 가질 수 있다.