---
상위 링크: "[[Concept]]"
---
# Type
개념은 일상생활에서 폭넓게 사용되는 일상적인 용어이기 때문에 컴퓨터 공학자들은 이에 타입type이라는 용어를 도입했다. 타입의 정의는 개념의 정의와 완전히 동일하다.

## Data Type
Concept은 객체를 분류하기 위한 기준이다. Type은 곧 Concept이다. 우리는 Data Type이라는 용어도 Concept의 어원에서 왔음을 알 수 있다.

메모리 레벨에서 0과 1로 이루어진 행렬에는 타입이 존재하지 않는다. 어떤 메모리 조각에 들어있는 값의 의미를 알 수 있는 사람은 아무도 없다. 그 의미는 해당 값을 사용하는 외부의 해석가에 의해서 결정된다.

결국 타입 없는 무질서의 세상에서 사람들은 이 데이터들에 대해 특정한 의미를 부여했다. 연산이 가능한 어떠한 데이터들은 숫자형으로 분류하고, 문자로써 읽힐 수 있으며 연결될 수 있다면 문자열 형으로 분류했다. 데이터가 참/거짓과 관련이 있다면 논리형으로 분류했다.

이러한 Data Type System은 결국 Concept이 객체를 분류하기 위한 개념이라는 점에서 매우 닮아있다.

이를 통해 타입과 관련한 두 가지 중요한 사실을 알 수 있다.

1. 타입은 데이터가 어떻게 사용되느냐에 관한 것이다.
2. 타입에 속한 데이터를 메모리에 어떻게 표현하는지는 외부러부터 철저하게 감춰진다.

이러한 의미에서 데이터 타입은 다음과 같이 정의될 수 있다.

> 데이터 타입은 메모리 안에 저장된 데이터의 종류를 분류하는 데 사용하는 메모리 집합에 관한 메타데이터이다. 데이터에 대한 분류는 암시적으로 어떤 종류의 연산이 해당 데이터에 대해 수행될 수 있는지를 결정한다.

## Generalization/Specialization
타입과 타입 사이에는 일반화/특수화 관계가 존재한다. A 타입의 extension이 B 타입의 extension에 포함된다면 A 타입은 B 타입보다 좀 더 특화된 행동을 할 수 있는 개념이 된다. 이 경우 A는 B에 비하여 특수한 개념이고, B는 A에 비하여 더 일반적인 개념이 된다.

객체지향에서 일반화/특수화 관계를 결정하는 것은 객체의 상태를 표현하는 데이터가 아닌 행동이다. 타입 간 일반화/특수화 관계가 성립하려면 한 타입이 다른 타입보다 더 특수하게 행동해야하며, 반대로 다른 타입은 한 타입보다 더 일반적으로 행동해야 한다. 객체 내부에 보관한 데이터의 특수성은 타입의 관계에서는 의미가 없다

결국 일반적인 타입은 특수한 타입에 비해 더 적은 수의 행동을 가지며, 특수한 타입은 더 많은 수의 행동을 가지게 된다. 또한 특수한 타입은 일반적인 타입이 할 수 있는 모든 행동을 동일하게 수행할 수 있어야 한다.

이러한 조건이 맞을 때에 일반적인 타입을 **Supertype**이라고 하며, 특수한 타입을 **Subtype**이라고 한다.


## Type은 추상화다.
어떤 시점의 객체를 다룰 때, 시간과 상태 변화라는 요소를 제거하고 오직 정적인 관점에서 상태와 행동만을 남긴다. 이러한 방식으로 객체의 동적인 특성을 추상화하여 정적인 상황에서 복잡성을 단순화 할 수 있다.

## Class와의 관계
객체지향 프로그래밍 언어에서 정적인 Type 모델은 클래스를 이용해 구현될 수 있다. 

클래스와 타입은 동일한 것이 아니다. 타입은 객체를 분류하기 위해 사용되는 개념이며, 클래스는 타입을 구현할 수 있는 매커니즘 중에 하나이다. 

그럼에도 불구하고 객체지향 패러다임을 주도하는 대부분의 프로그래밍 언어는 클래스를 기반으로 하기 때문에, 대부분의 사람들은 클래스와 타입을 동일한 개념이라고 생각한다. 클래스는 타입의 구현 외에도 코드를 재사용하는 용도로도 사용되기 때문에 클래스와 타입을 동일시하는 것은 수많은 오해와 혼란을 불러 일으키기도 한다.

