쓰레드는 User Level Thread와 Kernel Level Thread로 나눌 수 있습니다.
![[Pasted image 20230921221417.png]]
KLT가 지금까지 설명했던 구조와 유사하므로 먼저 설명하도록 하겠습니다. **Kernel Level Thread**는 운영체제의 지원을 받아 관리되는 쓰레드를 의미합니다. 이 쓰레드들의 TCB는 운영체제에 의하여 관리되며 운영체제는 이 정보들을 통해 쓰레드의 스케줄링 작업을 수행합니다. 각각의 쓰레드가 독립된 단위로 관리되기 때문에 하나의 쓰레드에서 I/O Operation 등의 이유로 작업이 중단된다 하더라도 다른 쓰레드는 프로세서를 점유할 수 있고 수행될 수 있다는 장점이 있습니다. 멀티코어 시스템에서는 각각의 쓰레드가 서로 다른 프로세서에 점유되어 병렬적으로 수행될 수도 있습니다. 반면 쓰레드간 context switch나 쓰레드 생성 및 상태 변환에 대해서 운영체제가 관여해야하기 때문에, 시스템이 커널모드로 자주 변환되어 오버헤드가 발생한다는 단점이 있습니다.

반면 **User Level Thread**는 운영체제의 레벨이 아닌 애플리케이션 레벨에서 직접 만들고 사용하는 쓰레드를 일컫습니다. 실제로 운영체제에서 관리되는 쓰레드는 아니지만, 애플리케이션 레벨의 코드로 쓰레드를 구현하여 마치 쓰레드를 쓰는 것과 같은 효과를 낼 수 있습니다. 이 경우 TCB는 애플리케이션 레벨에서 관리되므로 운영체제는 해당 프로세스가 여러개의 쓰레드를 갖고 있다는 정보를 전혀 모르게 됩니다.

ULT는 Thread간 전환이 애플리케이션 레벨에서 일어나기 때문에 커널의 도움을 받을 필요가 없습니다. 따라서 커널 모드로 진입할 필요가 없고 이는 오버헤드가 감소되는 효과를 낳습니다. 또한 쓰레드 간 전환을 할 때의 정책에 대해서 KLT는 OS에 종속적이지만, ULT는 OS와 상관없이 애플리케이션 레벨에서 자유롭게 정할 수 있다는 장점이 있습니다.

ULT는 위와 같은 장점이 있지만, 운영체제가 쓰레드의 존재를 모르기 때문에 발생하는 부작용도 존재합니다. 예를 들어 ULT 중 하나가 I/O Operation을 수행해야하여 [[System call]]을 호출할 때, 프로세스는 중단되고 커널이 프로세서를 점유하게 되는데 이 과정에서 모든 ULT가 중단됩니다. KLT 시스템에서는 하나의 쓰레드가 중단되더라도 다른 쓰레드들은 Ready 상태로 스케쥴링되어 프로세서를 점유할 수 있지만, ULT는 운영체제 레벨에서 하나의 프로세스로 관리되므로 전체가 Blocked 되는 결과를 낳습니다. 비슷한 이유로 ULT는 멀티코어 환경에서 병렬성의 장점을 전혀 가질 수 없게 됩니다.

현대의 시스템들은 ULT 와 KLT의 특성을 모두 활용하는 혼합된 방식을 채택하기도 합니다. 위 그림의 (c)가 그 예시입니다. 이러한 방법을 통해 각기 다른 쓰레드 모델의 장점을 극대화 할 수 있습니다.