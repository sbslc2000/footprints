## 개념
> **Program In Execution**
> **The Unit of Work**

프로세스란 프로그램이 수행되는 작업단위를 의미하며, 운영체제에 의하여 관리됩니다. 운영체제의 가장 큰 임무 중 하나는 디스크의 프로그램이 수행될 수 있도록 메모리로 가져오고, CPU가 어떤 프로세스의 명령어들을 수행하게 할지 결정하는 것입니다. 또한 모든 명령어가 수행되면 프로세스를 종료시키고 프로세스가 사용중이던 메모리와 자원들을 반환하는 작업도 수행합니다.

프로세스가 무엇인지 정확하게 이해하기 위해서는 우리가 생성한 프로그램이 어떻게 실제로 동작하는지 그 원리를 알아야할 필요가 있습니다. 
## In Memory…

우리가 작성한 프로그램은 소스코드로 디스크에 저장됩니다. 이 소스코드를 컴파일을 통해 실행가능한 파일로 변환하면 XXX.out 혹은 XXX.exe 라는 파일이 생성됩니다. 이것이 **프로그램**으로, 아직 수행중이지는 않지만 운영체제로부터 호출되어 수행될 수 있는 상태인 파일을 의미합니다.

이후 컴퓨터의 사용자에 의해 프로그램이 호출되면, 운영체제는 디스크에 있는 프로그램이 수행될 수 있도록 메모리로 가져오는 과정_loading_을 거칩니다. 메모리에 프로그램이 로딩된 이 instance를 **프로세스**라고 합니다. 이후 프로세스는 OS에 의해 프로세서를 점유하게 되고 프로그램은 수행됩니다.

![[Pasted image 20230921221019.png]]
메모리 상의 프로세스는 위와 같이 여러 섹션을 갖게 됩니다.
**TEXT 섹션**은 수행되는 명령어들을 포함하고 있는 섹션입니다. CPU의 PC Register가 이 공간의 주소를 가리키고 있으며, 하나의 명령어가 수행될 때마다 그 다음 위치의 메모리 공간을 가리켜 프로그램이 순차적으로 수행됩니다.
**DATA 섹션**은 전역 변수를 포함하고 있는 섹션입니다. 프로그램 수행 중 전역변수에 접근할 일이 있을 때 이 곳에 접근하게 됩니다.
**HEAP 섹션**은 동적할당된 변수를 포함하고 있는 메모리 공간입니다. C에서의 `malloc`, Java의 `new` 를 통해 생성된 변수들은 이 곳에 저장됩니다. 이 변수들은 선형적인 메모리 공간에서 낮은 주소부터 높은 주소로 채워집니다.
**STACK 섹션**은 메서드의 파라미터, 반환 값, 지역 변수들을 포함하고 있는 메모리 공간입니다. 이 변수들은 높은 주소부터 낮은 주소로 채워집니다. 흔히 얘기하는 StackOverflow란 함수의 루프 호출로 인하여 이 공간이 한계치를 넘겼을 때 발생하는 오류입니다. 함수의 호출을 통해 파라미터와 반환 값, 지역 변수들이 저장되어야 하는 공간이 무한히 늘어나기 때문입니다.

# 프로세스와 운영체제

OS의 주 목적은 프로세스들에게 시스템의 자원을 분배해서 프로그램들이 잘 수행될 수 있도록 돕는 것입니다.

OS는 위 임무를 수행하기 위해 [프로세스의 생명주기](Process%20생명주기와%20State)를 관리합니다. 어떤 프로세스를 시스템에 편입 시킬지, 어
떤 프로세스를 대기 시키거나 CPU를 점유하게 할 지, 어떤 프로세스를 시스템에서 삭제할 지를 결정합니다.

또한 시분할 서비스를 제공하기 위해서 OS는 CPU를 점유하는 프로세스를 빠르게 전환시켜 많은 프로세스들이 번갈아가며 수행될 수 있도록 해야합니다. 이러한 전환은 시분할 시스템에서 뿐만 아니라, I/O 요청을 통해 대기해야하는 프로세스를 CPU로부터 쫓아내고 기다리고 있는 다른 프로세스가 CPU를 차지하게 만드는 과정에서도 필요합니다. 이러한 전환 과정을 [[Context Switch]] 라고 합니다.

위 모든 과정을 수행하기 위해서 OS는 process를 식별하고 관리할 수 있는 데이터가 필요합니다. 운영체제는 프로세스의 정보를 담고 있는 구조체 자료구조를 만들어 프로세스를 관리합니다. 이 자료구조를 [[PCB]]라고 부릅니다.

## 독립적인 프로세스와 협력적인 프로세스

프로세스는 각각의 생명주기 동안 수행되면서 다른 프로세스들과 상호작용하기도 한다. 다른 프로세스들과 자료를 공유하는 프로세스는 **상호협력적인 프로세스**라고 하며, 다른 프로세스와 데이터를 공유하지 않고 수행되는 프로세스를 **독립적인 프로세스**라고 한다.

기본적으로 프로세스는 다른 프로세스의 주소 공간에 접근할 수 없다. 이는 서로의 영역을 제한하여 의도치 않은, 혹은 의도한(악의적인) 간섭이 발생하지 않게 만들기 위함이다. 따라서 서로 다른 프로세스들이 서로의 데이터를 참조하기 위해서는 [특별한 매커니즘](IPC.md)이 필요하다.


# Thread와는 무엇이 다른가?

Thread의 일반적인 용어의 뜻은 '흐름'입니다. 하나의 프로세스는 하나의 수행 흐름을 갖습니다. 하나의 PC Register 값이 실행 코드에 의해 변화하면서 종료에 이르게 됩니다.

반면 Thread는 하나의 프로세스 내에서 여러 수행흐름을 갖게 합니다. 이를 통해 하나의 프로세스가 2가지 이상의 task를 수행하는데에 용이하게 됩니다. 더 자세한 내용은 [여기](Thread.md)로

# I/O Bound Process 와 CPU Bound Process
빈번한 I/O 작업으로 인해 대부분의 시간을 I/O의 결과물을 기다리는데 사용하는 프로세스를 I/O Bound 프로세스, 대부분의 시간을 명령어를 수행하는데에 사용하는 프로세스를 CPU Bound Process라고 한다. 이는 멀티프로그래밍을 효율적으로 하기 위해서 고려되어야 하는 요소들이다.



# 프로세스 연산
## 프로세스 생성

프로세스는 다른 프로세스를 생성할 수 있다. 이 때 생성을 하는 프로세스를 **부모 프로세스**, 그리고 새롭게 만들어진 프로세스를 **자식 프로세스**라고 한다.

대부분의 운영체제는 최초의 프로세스 (Linux의 경우 systemd)를 생성하고 이후 최초의 프로세스를 부모로 하여 시스템 구동에 필요한 다양한 자식 프로세스(웹 서버, ssh 서버 등등)를 생성한다. 이렇게 생성된 프로세스들은 하나의 트리를 이룬다.

[[Zombie Process]]
[[Orphan Process]]

