# 제어의 역전*Inversion of Control*
제어의 역전은 프로그램의 제어 흐름 구조가 뒤바뀌는 것을 의미한다.

일반적으로 절차적 프로그램의 흐름은 main 메서드로부터 시작하여 코드를 수행하다가 사용할 오브젝트를 결정하고 해당 오브젝트를 만든 뒤 메서드 호출을 통해 제어를 넘긴다. 이후 해당 오브젝트에서도 동일한 과정이 반복된다. 이 구조에서는 각 오브젝트는 이후 프로그램의 동작 흐름을 결정하기 위해 오브젝트를 구성하는 작업에 능동적으로 참여한다.

```java
public static void main(String[] args) {
	//execute something
	SomeClass obj = new SomeClass();
	obj.callMethod();
}

...

class SomeObject() {
	private SomeOtherClass otherObj = new SomeOtherClass();

	public void callMethod() {
		//execute something ...
		otherObj.callOtherMethod();
	}
}
```

반면 제어의 역전이 잘 적용된 프로그램에서는 이러한 흐름이 거꾸로 뒤집혀 있다. 더 이상 각각의 오브젝트가 자신이 사용할 오브젝트를 스스로 결정하지 않으며, 오브젝트 본인 조차도 어디서부터 만들어지고 어디서 사용되는지 알 수 없다. 이 모든 일은 제어 권한이 자신이 아닌 다른 대상에게 위임되어있기 때문이다.

```java 
class SomeService { 

	private final SomeRepository repository;
	
	public void someMethod() {
		...
		repository.save(); //이 오브젝트가 실제로 무엇인지는 Service도 모른다.
	}
	
}
```

## 제어의 역전이 적용되어있는 사례

### Servlet
일반적인 자바 프로그램은 main()으로부터 시작하여 개발자가 미리 정한 순서를 따라 오브젝트가 생성된다. 반면 서블릿 모듈의 경우 이 실행을 개발자가 직접 제어할 수 있는 방법이 존재하지 않는다. 대신 서블릿에 대한 제어 권한을 갖고 있는 컨테이너가 적절한 시점에 서블릿 오브젝트를 만들고 메서드를 호출해준다.
### 템플릿 메서드 패턴
자주 변경될 여지가 있어 분리된 템플릿 메서드 패턴에서의 서브 클래스는 메서드가 언제 어떻게 사용될 지 자신은 모른다. 심지어는 조립 관계에 있어서 제공되지 않아 수행되지 않을 수도 있다. 일단 만들어 놓으면, 슈퍼 클래스에서 필요할 때 호출해서 사용할 것이다. 즉 제어권을 상위 템플릿 메서드에 넘기고 자신은 필요할 때 호출되어 사용되도록 한다는 제어의 역전 개념을 발견할 수 있다.
### 프레임워크 
라이브러리와 프레임워크는 코드 덩어리라는 점에서 공통점이 있지만 라이브러리의 사용은 제어를 프로그래머가 직접 결정하며, 프레임워크의 사용은 프레임워크가 제어하는 흐름 내에서 프로그래머가 수행될 수 있는 코드를 작성하는(끼워넣는) 것에 차이가 있다.
