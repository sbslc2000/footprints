### 유스케이스 구현하기
* 유스케이스
	* 도메인 로직에만 신경써야 하며, 입력 유효성 검증으로 오염되면 안된다.
	* 비즈니스 규칙을 검증할 책임이 있다.
* 입력 유효성 검증
	* 유스케이스를 호출하는 측에서 모두 검증했다고 믿을 수 있나?
		* 여러 곳에서 호출한다면 검증 로직이 분산됨
		* 유스케이스에서 검증한다면, 오염의 문제
	* **입력 모델*input model*이 이를 다루도록 하자**
* 유스케이스마다 입력 모델을 다르게 하자
	* 유스케이스간 결합도를 제거하여 부수효과가 발생하지 않는다.
* 비즈니스 규칙 검증
	* 입력 유효성과 차이는 무엇인가?
		* 도메인 모델의 현 상태에 접근해야하는가? -> 비즈니스 규칙
		* 도메인 모델에 접근하지 않고도 유효성을 판별할 수 있는가? -> 입력 유효성
	* 두 가지 방법이 있다.
		* best: 비즈니스 규칙을 도메인 엔티티 안에 
		* 여의치 않다면: 유스케이스 코드에서 
* 도메인 모델 구현
	* Rich Domain Model: 엔티티에서 가능한한 많은 로직 구현
	* Anemic Domain Model: 엔티티는 getter setter 기능으로 제한하고, 유스케이스에서 로직 구현
	* 필요에 따라 선택
* 출력 모델
	* 유스케이스마다 다르게 하자.
	* 가능한 한 호출자에게 꼭 필요한 데이터만을 반환할 수 있도록
* 읽기 전용 유스케이스
	* 쿼리를 위한 인커밍 전용 포트를 만들고, Query Service에서 구현
	* 쓰기가 가능한 유스케이스와 명확하게 구분된다!
	* CQS, CQRS 

## 웹 어댑터 구현하기
* 웹 어댑터는 '주도하는' 혹은 '인커밍' 어댑터이다. 
	* 외부로부터 요청을 받아 애플리케이션 코어를 호출하여 무슨 일을 해야할지 알려준다.
	* 어댑터와 유스케이스 사이에는 간접 계층인 포트가 존재해야한다.
		* 애플리케이션 코어가 외부 세계와 통신할 수 있는 곳에 대한 명세
* 웹 어댑터의 책임
	* HTTP 요청 수신 및 역직렬화
	* 입력 유효성 검사
		* 웹 어댑터의 입력 모델을 유스케이스의 입력 모델로 변환할 수 있다는 것을 검증
	* 유스케이스 호출
	* HTTP 응답 생성 및 직렬화
* HTTP와 관련된 것은 애플리케이션 계층으로 침투해서는 안된다.
	* HTTP를 사용하지 않는 또 다른 인커밍 어댑터의 요청을 유스케이스가 수행 가능
	* 이와 같은 경계는, 도메인과 애플리케이션 계층부터 개발하기 시작하면 자연스레 생긴다.
* 컨트롤러 나누기
	* 컨트롤러는 가능한 한 좁고 다른 컨트롤러와 가능한 한 적게 공유해야한다.
	* 한 도메인에 연산을 제공하는 컨트롤러는
		* 클래스의 코드 수가 늘어난다.
		* 테스트 코드의 수도 늘어난다.
		* 데이터 구조의 재활용을 촉진한다.
	* 각 연산 (유스케이스)에 대해 별도의 패키지를 만들고 별도의 컨트롤러를 만들자
		* 전용 모델 클래스가 생기며, package-private으로 작성된다면 실수로라도 다른 곳에서 재사용되지 않는다.
		* 클래스의 코드 수가 적어진다.
		* 각 어댑터의 독립적인 개발 및 확장이 가능해진다.]
* 정리
	* 어떤 도메인 로직도 수행하지 않는 어댑터를 만들어보라
	* 컨트롤러를 나눌 때는 모델을 공유하지 않는 여러 작은 클래스들을 만드는 것을 두려워해서는 안된다.

## 영속성 어댑터 구현하기
* 전통적인 계층형 아키텍처는 모든 것이 영속성 계층에 의존한다. "데이터베이스 주도 설계"
	* 헥사고날 아키텍처에서는 영속성 계층을 애플리케이션 계층의 플러그인으로 만들어 이 문제를 해결한다.
* 영속성 어댑터의 책임
	* 영속성 어댑터는 '주도되는' 혹은 '아웃고잉' 어댑터이다.
		* 애플리케이션에 의해 호출될 뿐, 애플리케이션을 호출하지는 않는다.
	* 입력을 받고, 입력을 데이터베이스 포맷으로 매핑하고, 데이터베이스에 보내고, 결과를 만들어 출력을 반환한다.
	* **영속성 어댑터의 입력 모델은 영속성 어댑터 내부에 있는 것이 아니라 애플리케이션 코어에 존재해야한다.**
		* 영속성 어댑터의 변경이 코어에 영향을 미치지 않아야 한다.
* 포트 인터페이스 나누기
	* 특정 엔티티가 필요로하는 연산을 모두 정의하는 인터페이스는 fat하다.
		* 단 하나의 메서드만 사용하더라도, 넓은 포트 인터페이스에 의존한다.
	* "필요없는 화물을 운반하는 무언가에 의존하고 있으면, 예상하지 못한 문제가 생길 수 있다." 
	* => 인터페이스 분리원칙
* 영속성 어댑터 나누기
	* 포트 인터페이스가 나눠진것과 별개로, 그 구현체 역시 나눠질 수 있다.
	* 일반적으로, 하나의 애그리거트 당 하나의 영속성 어댑터를 구현할 수도 있다.
	* 허나, 필요에 따라서 더 많이 나눌 수도 있다.
	* 도메인 코드는 포트에 의해 정의된 명세를 어떤 클래스가 충족시키는지 관심이 없다
* 매핑하기
	* 도메인 엔티티와 영속성 엔티티를 나누고, 어댑터에서 양방향 매핑하기
	* 도메인 엔티티와 영속성 엔티티를 하나로 유지한다면
		* JPA로 인해 도메인 모델에서의 타협 필요 (강제로 기본 생성자를 넣는다거나, @ManyToOne 같은 DB 레벨의 애노테이션이 끼어든다거나)
	* 영속성 측면과의 타협 없이 풍부한 도메인 모델을 생성하고 싶다면, 도메인 모델과 영속성 모델을 어댑터 단에서 매핑하는 것이 좋다.
* 트랜잭션
	* 하나의 유스케이스에서 일어나는 모든 쓰기 작업에 걸쳐있어야 한다.
	* 영속성 어댑터는 데이터베이스 연산이 같은 유스케이스에 포함되는지 알지 못한다.
	* 트랜잭션의 책임은 영속성 어댑터를 호출을 관장하는 애플리케이션 서비스에 위임해야한다.
	* @Transactional, AOP weaving
* 정리 : 도메인 코드에 플러그인처럼 동작하는 영속성 어댑터를 만들면, 도메인 코드가 영속성과 관련된 것들로부터 분리되어 풍부한 모델을 만들 수 있다.