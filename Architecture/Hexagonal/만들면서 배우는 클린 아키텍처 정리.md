### 유스케이스 구현하기
* 유스케이스
	* 도메인 로직에만 신경써야 하며, 입력 유효성 검증으로 오염되면 안된다.
	* 비즈니스 규칙을 검증할 책임이 있다.
* 입력 유효성 검증
	* 유스케이스를 호출하는 측에서 모두 검증했다고 믿을 수 있나?
		* 여러 곳에서 호출한다면 검증 로직이 분산됨
		* 유스케이스에서 검증한다면, 오염의 문제
	* **입력 모델*input model*이 이를 다루도록 하자**
* 유스케이스마다 입력 모델을 다르게 하자
	* 유스케이스간 결합도를 제거하여 부수효과가 발생하지 않는다.
* 비즈니스 규칙 검증
	* 입력 유효성과 차이는 무엇인가?
		* 도메인 모델의 현 상태에 접근해야하는가? -> 비즈니스 규칙
		* 도메인 모델에 접근하지 않고도 유효성을 판별할 수 있는가? -> 입력 유효성
	* 두 가지 방법이 있다.
		* best: 비즈니스 규칙을 도메인 엔티티 안에 
		* 여의치 않다면: 유스케이스 코드에서 
* 도메인 모델 구현
	* Rich Domain Model: 엔티티에서 가능한한 많은 로직 구현
	* Anemic Domain Model: 엔티티는 getter setter 기능으로 제한하고, 유스케이스에서 로직 구현
	* 필요에 따라 선택
* 출력 모델
	* 유스케이스마다 다르게 하자.
	* 가능한 한 호출자에게 꼭 필요한 데이터만을 반환할 수 있도록
* 읽기 전용 유스케이스
	* 쿼리를 위한 인커밍 전용 포트를 만들고, Query Service에서 구현
	* 쓰기가 가능한 유스케이스와 명확하게 구분된다!
	* CQS, CQRS 

## 웹 어댑터 구현하기
* 웹 어댑터는 '주도하는' 혹은 '인커밍' 어댑터이다. 
	* 외부로부터 요청을 받아 애플리케이션 코어를 호출하여 무슨 일을 해야할지 알려준다.
	* 어댑터와 유스케이스 사이에는 간접 계층인 포트가 존재해야한다.
		* 애플리케이션 코어가 외부 세계와 통신할 수 있는 곳에 대한 명세
* 웹 어댑터의 책임
	* HTTP 요청 수신 및 역직렬화
	* 입력 유효성 검사
		* 웹 어댑터의 입력 모델을 유스케이스의 입력 모델로 변환할 수 있다는 것을 검증
	* 유스케이스 호출
	* HTTP 응답 생성 및 직렬화
* HTTP와 관련된 것은 애플리케이션 계층으로 침투해서는 안된다.
	* HTTP를 사용하지 않는 또 다른 인커밍 어댑터의 요청을 유스케이스가 수행 가능
	* 이와 같은 경계는, 도메인과 애플리케이션 계층부터 개발하기 시작하면 자연스레 생긴다.
* 컨트롤러 나누기
	* 컨트롤러는 가능한 한 좁고 다른 컨트롤러와 가능한 한 적게 공유해야한다.
	* 한 도메인에 연산을 제공하는 컨트롤러는
		* 클래스의 코드 수가 늘어난다.
		* 테스트 코드의 수도 늘어난다.
		* 데이터 구조의 재활용을 촉진한다.
	* 각 연산 (유스케이스)에 대해 별도의 패키지를 만들고 별도의 컨트롤러를 만들자
		* 전용 모델 클래스가 생기며, package-private으로 작성된다면 실수로라도 다른 곳에서 재사용되지 않는다.
		* 클래스의 코드 수가 적어진다.
		* 각 어댑터의 독립적인 개발 및 확장이 가능해진다.]
* 정리
	* 어떤 도메인 로직도 수행하지 않는 어댑터를 만들어보라
	* 컨트롤러를 나눌 때는 모델을 공유하지 않는 여러 작은 클래스들을 만드는 것을 두려워해서는 안된다.

## 영속성 어댑터 구현하기
* 전통적인 계층형 아키텍처는 모든 것이 영속성 계층에 의존한다. "데이터베이스 주도 설계"
	* 헥사고날 아키텍처에서는 영속성 계층을 애플리케이션 계층의 플러그인으로 만들어 이 문제를 해결한다.
* 영속성 어댑터의 책임
	* 영속성 어댑터는 '주도되는' 혹은 '아웃고잉' 어댑터이다.
		* 애플리케이션에 의해 호출될 뿐, 애플리케이션을 호출하지는 않는다.
	* 입력을 받고, 입력을 데이터베이스 포맷으로 매핑하고, 데이터베이스에 보내고, 결과를 만들어 출력을 반환한다.
	* **영속성 어댑터의 입력 모델은 영속성 어댑터 내부에 있는 것이 아니라 애플리케이션 코어에 존재해야한다.**
		* 영속성 어댑터의 변경이 코어에 영향을 미치지 않아야 한다.
* 포트 인터페이스 나누기
	* 특정 엔티티가 필요로하는 연산을 모두 정의하는 인터페이스는 fat하다.
		* 단 하나의 메서드만 사용하더라도, 넓은 포트 인터페이스에 의존한다.
	* "필요없는 화물을 운반하는 무언가에 의존하고 있으면, 예상하지 못한 문제가 생길 수 있다." 
	* => 인터페이스 분리원칙
* 영속성 어댑터 나누기
	* 포트 인터페이스가 나눠진것과 별개로, 그 구현체 역시 나눠질 수 있다.
	* 일반적으로, 하나의 애그리거트 당 하나의 영속성 어댑터를 구현할 수도 있다.
	* 허나, 필요에 따라서 더 많이 나눌 수도 있다.
	* 도메인 코드는 포트에 의해 정의된 명세를 어떤 클래스가 충족시키는지 관심이 없다
* 매핑하기
	* 도메인 엔티티와 영속성 엔티티를 나누고, 어댑터에서 양방향 매핑하기
	* 도메인 엔티티와 영속성 엔티티를 하나로 유지한다면
		* JPA로 인해 도메인 모델에서의 타협 필요 (강제로 기본 생성자를 넣는다거나, @ManyToOne 같은 DB 레벨의 애노테이션이 끼어든다거나)
	* 영속성 측면과의 타협 없이 풍부한 도메인 모델을 생성하고 싶다면, 도메인 모델과 영속성 모델을 어댑터 단에서 매핑하는 것이 좋다.
* 트랜잭션
	* 하나의 유스케이스에서 일어나는 모든 쓰기 작업에 걸쳐있어야 한다.
	* 영속성 어댑터는 데이터베이스 연산이 같은 유스케이스에 포함되는지 알지 못한다.
	* 트랜잭션의 책임은 영속성 어댑터를 호출을 관장하는 애플리케이션 서비스에 위임해야한다.
	* @Transactional, AOP weaving
* 정리 : 도메인 코드에 플러그인처럼 동작하는 영속성 어댑터를 만들면, 도메인 코드가 영속성과 관련된 것들로부터 분리되어 풍부한 모델을 만들 수 있다.
## 아키텍쳐 요소 테스트하기
* 테스트 피라미드
	* 테스트는 만드는 비용이 적고, 유지보수하기 쉽고, 빨리 실행되고, 안정적인 작은 크기의 테스트들에 대해 높은 커버리지를 유지해야한다.
	* 단위와 단위를 넘는, 아키텍처와 아키텍처를 넘는 테스트는 비용이 비싸고, 느리고, 깨지기 쉽다.
	* 테스트가 비싸질수록 커버리지 목표는 낮게 잡아야 한다.
	* 단위 테스트: 하나의 클래스를 인스턴스화하여 기능들을 테스트
		* 다른 클래스에 의존한다면 목(mock)으로 대체
	* 통합 테스트: 여러 유닛을 인스턴스화하고 시작점이 되는 클래스의 인터페이스로 데이터를 보낸 후 유닛들의 네트워크가 기대한대로 잘 동작하는지 검증
	* 시스템 테스트 : 애플리케이션을 구성하는 모든 객체 네트워크를 가동시켜 특정 유스케이스가 전 계층에서 잘 동작하는지 검증
* 서비스 테스트
	* 일반적으로 상태가 없기 때문에 도메인 엔티티 테스트와 다르게 then에서 값 검증이 불가
	* 서비스가 의존 대상의 특정 메서드와 상호작용 했는지 여부를 검증
	* 모든 동작을 검증한다면 변경에 취약하므로, 핵심만 골라 집중하여 테스트
* 웹 어댑터 테스트
	* 웹 컨트롤러는 일반적으로 프레임워크에 강하게 묶여있기 때문에, 격리된 상태로 테스트하기 보다는 프레임워크와 통합된 상태로 테스트하는 것이 합리적
* 영속성 어댑터 테스트
	* 데이터베이스를 모킹해야할까
		* 커버리지는 동일
		* 실제 연동했을 때 SQL 구문 오류나 매핑에러 등으로 문제 발생할 확률 높아짐
		* 스프링은 기본적으로 인메모리 DB를 사용하므로 실용적
		* 허나 프로덕션 환경이랑 맞지 않을 수도
		* Testcontainers 같은 라이브러리는 이런 측면에서 매우 유용하다.
* 얼마만큼의 테스트가 충분할까?
	* 라인 커버리지는 테스트 성공을 측정하는데 있어서는 잘못도니 지표이다.
		* 100%라 하더라도 버그가 잘 잡혔는지 확신할 수 없다.
	* 얼마나 마음 편하게 소프트웨어를 배포할 수 있느냐를 테스트의 성공 기준으로 삼으면 된다.
		* 더 자주 배포할수록 테스트를 더 신뢰할 수 잇다.
			* 일년에 두 번만 배포한다면 테스트를 신뢰하기 어려울 것
	* 테스트가 이 버그를 왜 잡지 못했을까?를 생각하고, 이를 커버할 수 있는 테스트를 추가해보아라.
	* 테스트는 기능 개발 후에 한다면 귀찮은 작업이지만, 개발 중에 이뤄진다면 훌륭한 개발 도구가 된다.
	* 리팩터링할 때마다 테스트코드도 변경해야한다면 테스트는 테스트로서의 가치를 잃는다.
* 육각형 아키텍처에서
	* 입출력 포트는 테스트에서 아주 뚜렷한 모킹 지점이 된다.
	* 모킹이 버거워지거나, 특정 부분을 커버하기 위해 어떤 종류의 테스트를 써야 할지 모르겠다면 이는 경고 신호다.