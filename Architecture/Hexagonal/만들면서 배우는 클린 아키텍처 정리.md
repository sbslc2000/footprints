### 유스케이스 구현하기
* 유스케이스
	* 도메인 로직에만 신경써야 하며, 입력 유효성 검증으로 오염되면 안된다.
	* 비즈니스 규칙을 검증할 책임이 있다.
* 입력 유효성 검증
	* 유스케이스를 호출하는 측에서 모두 검증했다고 믿을 수 있나?
		* 여러 곳에서 호출한다면 검증 로직이 분산됨
		* 유스케이스에서 검증한다면, 오염의 문제
	* **입력 모델*input model*이 이를 다루도록 하자**
* 유스케이스마다 입력 모델을 다르게 하자
	* 유스케이스간 결합도를 제거하여 부수효과가 발생하지 않는다.
* 비즈니스 규칙 검증
	* 입력 유효성과 차이는 무엇인가?
		* 도메인 모델의 현 상태에 접근해야하는가? -> 비즈니스 규칙
		* 도메인 모델에 접근하지 않고도 유효성을 판별할 수 있는가? -> 입력 유효성
	* 두 가지 방법이 있다.
		* best: 비즈니스 규칙을 도메인 엔티티 안에 
		* 여의치 않다면: 유스케이스 코드에서 
* 도메인 모델 구현
	* Rich Domain Model: 엔티티에서 가능한한 많은 로직 구현
	* Anemic Domain Model: 엔티티는 getter setter 기능으로 제한하고, 유스케이스에서 로직 구현
	* 필요에 따라 선택
* 출력 모델
	* 유스케이스마다 다르게 하자.
	* 가능한 한 호출자에게 꼭 필요한 데이터만을 반환할 수 있도록
* 읽기 전용 유스케이스
	* 쿼리를 위한 인커밍 전용 포트를 만들고, Query Service에서 구현
	* 쓰기가 가능한 유스케이스와 명확하게 구분된다!
	* CQS, CQRS 

## 웹 어댑터 구현하기
* 웹 어댑터는 '주도하는' 혹은 '인커밍' 어댑터이다. 
	* 외부로부터 요청을 받아 애플리케이션 코어를 호출하여 무슨 일을 해야할지 알려준다.
	* 어댑터와 유스케이스 사이에는 간접 계층인 포트가 존재해야한다.
		* 애플리케이션 코어가 외부 세계와 통신할 수 있는 곳에 대한 명세
* 웹 어댑터의 책임
	* HTTP 요청 수신 및 역직렬화
	* 입력 유효성 검사
		* 웹 어댑터의 입력 모델을 유스케이스의 입력 모델로 변환할 수 있다는 것을 검증
	* 유스케이스 호출
	* HTTP 응답 생성 및 직렬화
* HTTP와 관련된 것은 애플리케이션 계층으로 침투해서는 안된다.
	* HTTP를 사용하지 않는 또 다른 인커밍 어댑터의 요청을 유스케이스가 수행 가능
	* 이와 같은 경계는, 도메인과 애플리케이션 계층부터 개발하기 시작하면 자연스레 생긴다.
* 컨트롤러 나누기
	* 컨트롤러는 가능한 한 좁고 다른 컨트롤러와 가능한 한 적게 공유해야한다.
	* 한 도메인에 연산을 제공하는 컨트롤러는
		* 클래스의 코드 수가 늘어난다.
		* 테스트 코드의 수도 늘어난다.
		* 데이터 구조의 재활용을 촉진한다.
	* 각 연산 (유스케이스)에 대해 별도의 패키지를 만들고 별도의 컨트롤러를 만들자
		* 전용 모델 클래스가 생기며, package-private으로 작성된다면 실수로라도 다른 곳에서 재사용되지 않는다.
		* 클래스의 코드 수가 적어진다.
		* 각 어댑터의 독립적인 개발 및 확장이 가능해진다.]
* 정리
	* 어떤 도메인 로직도 수행하지 않는 어댑터를 만들어보라
	* 컨트롤러를 나눌 때는 모델을 공유하지 않는 여러 작은 클래스들을 만드는 것을 두려워해서는 안된다.