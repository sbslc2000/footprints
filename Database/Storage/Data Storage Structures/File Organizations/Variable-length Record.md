---
상위 개념: "[[File Organizations]]"
---
# Variable-length Record
데이터베이스 시스템은 문자열, 배열 혹은 리스트와 같은 필드를 위해 가변 길이 레코드를 필요로 한다.

## Structure
가변 길이 레코드를 구현하기 위해서는 두 가지의 문제를 해결해야 한다.

1. 레코드 내에서 각 필드들의 시작점을 어떻게 구분할 것인가?
2. 블록 내에서 레코드의 시작점을 어떻게 구분할 것인가?

### 필드 구분
가변 길이의 속성을 지닌 레코드는 일반적으로 두 부분으로 구성된다.

* 구조가 같은 릴레이션의 모든 레코드에 대해 같은 고정 길이 정보를 갖는 처음 부분
* 가변 길이 속성의 내용으로 구성된 그 다음 부분

![](https://i.imgur.com/EisAI4X.png)

위 레코드에서 \[21, 5], \[26, 10] 와 같은 표현은 속성의 오프셋과 길이를 의미한다. 레코드의 첫 부분은 가변 길이를 갖는 필드들의 오프셋과 길이 정보로 구성된다. (이 정보들은 고정 길이로 구성된다.)

이후 레코드의 고정 길이 필드가 나타나고, 널 비트맵이 나타난 이후, 가변 필드들이 순서대로 나타난다. 이 구조라면 가변 길이의 필드더라도 '레코드의 세번째 필드를 가져와줘' 라는 명령을 손쉽게 수행할 수 있다.

중간에 포함되어있는 널 비트맵은 레코드 내 특정 필드가 null인지 아닌지를 표현하는 비트문자열이다.

### 블록 내 레코드 구분 - Slot Page Structure
![](https://i.imgur.com/EXGnOtm.png)

블록 내에서 레코드를 구분하기 위해서는 위와 같은 구조를 가져야 한다. 블록의 헤더에 다음과 같은 정보를 기입하여 유지한다.

* 블록 내의 레코드 개수
* 각 레코드의 위치와 크기를 포함하고 있는 엔트리 배열
* 블록이 끝나는, 빈 공간이 시작되는 지점

블록 내 레코드는 항상 끝에서부터 인접하게 할당된다. 할당되고 나면, 해당 블록에 접근할 수 있는 오프셋와 길이를 갖는 엔트리가 헤더에 추가된다. 또한, 블록이 채워진 만큼 블록이 끝나는 지점에 대한 포인터를 업데이트 해주어야 한다. 해당 포인터는 다음번에 레코드가 생성될 때 사용된다.

만약 레코드가 삭제된다면, 엔트리를 삭제하고, 삭제한 공간으로 중간에 구멍이 생기지 않게 레코드를 전부 이동시켜주어야 한다. 이후 블록이 끝나는 지점을 가리키는 포인터를 업데이트 해주어야 한다. 일반적으로 이 작업은 하나의 블록 내에서 발생하기에 비용이 크지 않다. 
