---
상위 개념: "[[Join Operation Processing]]"
---
# Nested-loop Join
중첩 루프 조인은 중첩 for 문 알고리즘을 통해 조인 연산을 처리한다. 이 때 바깥쪽 중첩문에 해당하는 릴레이션을 외부 릴레이션*outer relation*, 안쪽 반복문에 해당하는 릴레이션을 내부 릴레이션*inner relation*이라고 한다. 

## 알고리즘
```
// theta R to S 
for each tuple r in R
	for each tuple s in S
		test pair (r, s) to see if they satisfy the join condition
		if they do, add rs to the result
	end
end
```
릴레이션 R의 각각의 튜플 r에 대해서, 릴레이션 S의 각각의 튜플 s와 조인 조건에 맞는지 검사하여 맞다면 결과 셋에 추가하고, 아니라면 다음 조사를 이어간다.

## 비용
만약 둘 중 하나의 릴레이션이 메인 메모리에 모두 올라올 수 있다면, 그 릴레이션을 내부 릴레이션으로 사용하는 것이 좋다.

### 최악의 경우
각 릴레이션의 한 블록씩만을 버퍼에 담을 수 있는 최악의 상황이라면 비용은 다음과 같다. 
* 전송 횟수 : $n_r * b_s + b_r$
* 탐색 횟수 : $n_r + b_r$

$n_r$은 외부 릴레이션의 레코드 개수이다. 바깥쪽 for문에서 R의 블록을 가져오기 위한 전송횟수 $b_r$번과, $R$의 레코드들마다 내부 릴레이션의 모든 블록을 필요로 하므로 $n_r * b_r$ 이 더해져야 한다.

### 최선의 경우
모든 릴레이션을 메모리에 담을 수 있는 경우 최선의 상황이 된다.
* 전송 횟수 : $b_r + b_s$
* 탐색 횟수 : 2

외부 릴레이션과 내부 릴레이션은 각각 한 번씩만 읽어들이면 되므로 위와 같은 전송 횟수와 탐색 횟수를 갖는다.


			(근데 알고리즘에 따라서 동작하면 다음처럼 돌아야 하지 않나?)
			1. 외부 루프를 돌리기 위해 외부 블록의 첫번째 블록을 가져온다 => 디스크 탐색 발생
			2. 내부 루프를 돌리기 위해 내부 블록을 가져온다. => 디스크 탐색 발생
			3. 내부 루프를 모두 돌린다. 내부 릴레이션의 모든 데이터가 버퍼에 적재되었다. => 디스크탐색 x, 이미 2에서 탐색했음
			4. 외부 루프를 마저 돌리기 위해 외부 블록의 두번째 블록을 가져온다. => 디스크 탐색 발생
			5. 나머지 루프를 돈다 => 디스크 탐색 x
			최적화가 된다면 모를까..

### 하나의 릴레이션만 메모리에 올라올 수 있다면?
하나의 릴레이션이 메모리에 올라올 수 있다면 내부 릴레이션이 올라오는 것이 좋다. 내부 릴레이션이 올라오는 경우 비용은 최선의 경우와 동일하다.

* 전송 횟수 : 첫번째 내부 루프를 돌면서 내부 릴레이션을 전송(이는 모두 버퍼에 저장되어 추가적인 전송을 요구하지 않는다)과, 각 루프를 돌며 가져오는 외부 릴레이션 블록 전송의 합, $b_r + b_s$
* 탐색 횟수: 내부 릴레이션을 읽기 위한 탐색과 외부 릴레이션을 읽기 위한 탐색, 2번

