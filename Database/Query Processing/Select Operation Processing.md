---
상위 개념: "[[Query Processing]]"
---
# Select Operation Processing
* $t_S$ : 탐색 시간
* $t_T$ : 전송 시간
* $b_r$ : 릴레이션의 블록 수
* $h_i$ : 인덱스의 깊이

## A1 : Linear search
조건절에 사용할 수 있는 인덱스가 없는 경우, 각 파일 블록을 스캔하고 모든 레코드에 대해 조건절을 검사한다.

(데이터가 연속된 블록에 위치하는 경우)
$$t_S +  b_r * t_T$$

## A1 : Linear search, Equality on Key
조건절에 사용할 수 있는 인덱스가 없고 키에 대한 동등성 조건인 경우, 파일 블록을 스캔하다가 조건에 맞는 레코드를 발견하면 쿼리는 종료된다.

(평균)
$$ t_S + (b_r / 2) * t_T $$

## A2 : Clustering B$^+$-tree Index, Equality on Key
클러스터링 인덱스를 사용중이고, 키에 대한 동등성 조건인 경우 절차는 다음과 같다.
1. 검색 키 v를 포함하는 단말노드를 찾는다.
2. 단말 노드에서 v에 대한 포인터를 획득한 후, 해당 레코드를 조회한다.

단말 노드를 찾기까지 인덱스의 깊이 만큼의 임의 I/O가 발생하며, 이후 레코드를 가져오기 위해 추가적인 1번의 임의 I/O가 발생한다.
$$ (h_i + 1) * (t_S + t_T) $$
만약 단말 노드를 제외한 내부 노드가 이미 버퍼에 있다고 가정하면, 성능은 다음과 같다.
$$t_S + t_T $$ 
## A3 : Clustering B$^+$-tree Index, Equality on Non-key
클러스터링 인덱스를 사용중이고, 키가 아닌 경우에 대한 동등성이라면 결과는 여러개의 레코드 일 수 있다.
가장 먼저 검색키 v를 포함하는 단말노드를 찾은 뒤, v가 아닐 때까지 순차탐색을 수행한다. 이 과정에서 다음 노드로 넘어가는 경우 추가적인 블록 읽기가 발생할 수 있다. 클러스터링 인덱스를 가정하고 있으므로, 이 때의 추가 블록 읽기는 탐색 시간이 들지 않는다.

* b : v에 해당하는 데이터를 담고 있는 블록 수
$$ h_i * (t_S + t_T) + t_S + b * t_T$$

## A4 : Secondary B$^+$-tree Index, Equality on Key
보조 인덱스를 사용중이고, 키에 대한 동등성 조건인 경우, 로직과 성능은 A2와 동일하다.

## A4 : Secondary B$^+$-tree Index, Equality on Non-key
보조 인덱스를 사용중이고, 키가 아닌 것에 동등성 조건인 경우, 절차는 다음과 같다.
1. 검색 키 v를 갖는 단말 노드를 찾는다.
2. 단말 노드를 순회하며 검색 키 v에 해당하는 레코드들을 가져온다.

이 과정은 레코드 포인터의 개수만큼의 임의 I/O를 발생시키므로, 많은 수의 레코드가 검색된다면 선형 검색보다 비용이 더 나빠질 수도 있다.

* n : 조건에 부합하는 레코드 개수
$$ (h_i + n) * (t_S + t_T)$$ 

## A5 : Clustering B$^+$-tree Index, Comparison
클러스터링 인덱스에서 비교 조건은 두 경우로 나눌 수 있다.

1. A < v , A <= v 인 경우
이 경우 인덱스를 사용할 필요 없다. 파일의 시작점부터 조건에 맞는 것까지 블록을 스캔하며 데이터를 가져온다.

2. A > v, A >= v인 경우
인덱스를 사용하여 검색키가 v인 레코드를 찾은 후, 해당 위치로부터 파일 끝 까지 스캔하며 데이터를 가져온다.
이 경우 비용 추정치는 A3와 동일하다.

## A6 : Secondary B$^+$-tree Index, Comparison
보조 인덱스에서 비교조건인 경우, 인덱스를 통해 검색키에 해당하는 레코드를 찾은 뒤, 단말 노드를 방향에 맞게 선형 순회하며 레코드들을 가져온다.

비용 추정치는 A4와 같다. 이 역시 꺼내오는 레코드의 수가 큰 경우 선형 검색보다 비용이 더 들 수 있다.

## A7: Conjunctive selection using one index
하나의 인덱스를 사용하는 논리곱 연산은 다음과 같은 절차를 갖는다.

1. 인덱스를 사용할 수 있는 속성을 포함하는 단순 조건이 있는지 결정한다.
	1. 만약 그러한 조건이 있는 경우, A2~A6 중 하나를 사용해 그 조건을 만족하는 레코드를 뽑아낸다.
	2. 없는 경우, 하나의 속성을 골라 A1을 통해 전부 가져온다.
2. 이렇게 얻어낸 레코드들에 대해 남아있는 단순조건을 만족하는지 검사한다.

A7 알고리즘의 비용은 선택된 알고리즘의 비용과 같다.

## A8: Conjunctive selection using composite index
만약 선택 연산이 두 개 이상의 속성에 대한 동등 비교 조건으로 구성되고 복합 인덱스가 이 속성에 대해 구성되어 있는 경우, 인덱스를 이용해 직접 결과를 얻어낼 수 있다.

인덱스의 종류에 따라 A2, A3, A4 알고리즘을 사용할 수 있다.

## A9: Conjective selection by intersection identifiers
모든 단순 조건에 대해 인덱스를 사용할 수 있는 경우, 각각의 단순 조건들에 대해 얻어낸 결과를 교집합함으로써 쿼리의 결과를 얻어낼 수 있다.

A9 알고리즘의 비용은 각각의 인덱스 스캔 비용의 합과 결과 레코드를 얻어 내는데 드는 비용을 더한 것이다. 
## A10: disjunctive selection by union of identifiers
만약 논리합 선택 연산의 모든 조건에 대해 인덱스가 존재하는 경우, 각 단순조건을 인덱스로 조회한 튜플들을 합집합 함으로써 결과를 얻어낼 수 있다.

허나 하나의 단순조건이라도 인덱스가 없는 경우, 릴레이션을 선형 스캔해야한다.