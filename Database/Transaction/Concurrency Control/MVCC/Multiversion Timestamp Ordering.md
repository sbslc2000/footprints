---
상위 개념: "[[MVCC]]"
---
# Multiversion Timestamp Ordering
다중 버전 타임스탬프 순서(Multiversion Timestamp Ordering, MVTO)는 잠금을 사용하지 않는 다중 버전 동시성 제어 프로토콜 중 하나이다. 이 기법의 핵심은 데이터 항목마다 여러 개의 버전을 유지하고, 각 트랜잭션에 고유한 타임스탬프를 부여하여 동시성을 높이는 데 있다. 이를 통해 읽기 연산이 쓰기 연산에 의해 차단(blocking)되는 상황을 방지한다. 읽기 작업은 절대 기다리지 않는다는 큰 장점이 있지만, 쓰기 트랜잭션이 롤백될 수 있으며 여러 버전을 저장해야 하는 오버헤드가 존재한다.

## 데이터 버전의 구조
MVTO에서 모든 데이터 항목 `Q`는 일련의 버전 `<Q1, Q2, ..., Qm>`을 가진다. 4 각 버전 `Qi`는 다음 세 가지 정보를 포함한다.

- **Content**: 해당 버전의 실제 데이터 값이다. 
- **W-timestamp(Qi)**: 이 버전을 생성(write)한 트랜잭션의 타임스탬프이다. 
- **R-timestamp(Qi)**: 이 버전을 성공적으로 읽은 트랜잭션들 중 가장 큰 타임스탬프이다. 
    
## 읽기(Read) 연산
타임스탬프 `TS(T)`를 가진 트랜잭션 `T`가 데이터 `Q`를 읽으려고 할 때, 시스템은 `Q`의 버전들 중에서 `W-timestamp`가 `TS(T)`보다 작거나 같은 것 중 가장 큰 값을 가진 버전, `Qk`를 선택한다. 8 `T`는 `Qk`의 값을 읽게 되며, 이 읽기 연산은 항상 성공한다. 읽기가 끝나면 시스템은 `Qk`의 `R-timestamp`를 기존 값과 `TS(T)` 중 더 큰 값으로 갱신한다.

## 쓰기(Write) 연산
트랜잭션 `T`가 데이터 `Q`에 쓰려고 할 때, 먼저 읽기 연산과 동일한 규칙으로 `Qk` 버전을 찾는다. 그 후, 시스템은 직렬 가능성이 깨지지 않는지 확인하기 위해 다음 규칙을 적용한다.

1. **충돌 검사**: 만약 `TS(T)`가 `Qk`의 `R-timestamp`보다 작다면, 이는 `T`보다 더 늦은 타임스탬프를 가진 트랜잭션이 이미 `T`가 만들었어야 할 버전을 보지 못하고 `Qk`를 읽었음을 의미한다. 이 경우 타임스탬프 순서가 위배되므로, 트랜잭션 `T`는 롤백된다. 
2. **새 버전 생성**: 위 충돌 검사를 통과하면, `T`는 `Q`의 새로운 버전을 생성한다. 이 새 버전의 `W-timestamp`와 `R-timestamp`는 모두 `TS(T)` 값으로 초기화된다. 
    
