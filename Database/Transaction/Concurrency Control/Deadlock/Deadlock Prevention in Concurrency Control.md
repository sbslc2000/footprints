---
상위 개념: "[[Deadlock in Concurrency Control]]"
---
# Deadlock Prevention in Concurrency Control
교착 상태를 예방하기 위한 두 가지 접근 방법이 있다. 하나는 잠금을 요청하는 순서에 대기 사이클이 발생하지 않도록 하거나, 필요한 잠금을 한꺼번에 요청하도록 하는 것이다. 또 다른 방법은 잠금을 대기하는 것이 교착 상태를 일으킬 것 같으면 잠금을 대기하도록 하는 대신 트랜잭션을 롤백하는 방법이다.

## 대기 사이클 발생 방지
트랜잭션이 실행 전에 필요한 모든 잠금을 한꺼번에 요청한다면 (모든 잠금이 하나의 단계에서 전부 걸리거나 아니면 하나도 걸리지 않는다면) 데드락은 발생하지 않는다. 하지만 이 방식은 트랜잭션이 시작하기 전에 어떤 데이터 항목에 잠금을 걸어야하는지 미리 가능하며, 데이터 항목의 이용률이 떨어진다는 단점이 있다.

또 다른 방법은 모든 데이터 항목에 완전 순서(total order)를 매긴 다음 트랜잭션이 이 순서에 따라 잠금을 요청하도록 하는 것이다.

## 선점과 트랜잭션 롤백
선점과 롤백 방식은 각 트랜잭션에 타임스탬프를 부여하여 구현할 수 있다.

1. 기다리기-죽기(wait-die) : 비선점 기법이며, 트랜잭션이 $T_i$가 현재 $T_j$가 잠금을 건 데이터 항목을 요청했을 때, $T_i$의 타임스탬프가 $T_j$의 타임스탬프보다 작은 경우에만 $T_i$는 대기할 수 있으며, 그렇지 않다면 $T_i$는 롤백한다.
2. 죽이기-기다리기(wound-wait): 선점 기법이며, 트랜잭션이 $T_i$가 현재 $T_j$가 잠금을 건 데이터 항목을 요청했을 때, $T_i$의 타임스탬프가 $T_j$의 타임스탬프보다 더 큰 경우에만 $T_i$는 대기할 수 있으며, 그렇지 않다면 $T_j$를 롤백한다.

또 다른 방법은 **잠금 타임아웃**(lock timeout)을 기반으로 하는 방법이다. 트랜잭션은 잠금을 얻기 위해 요청을 한 뒤 일정 시간이상 잠금을 얻지 못하면 롤백한다. 이는 교착 상태 예방과 교착 상태 탐지 및 복구의 중간 단계에 있다고 볼 수 있다.
