---
상위 개념: "[[Timestamp-ordering Protocol]]"
---
# Thomas' Write Rule
토마스의 쓰기 규칙(Thomas' Write Rule)은 타임스탬프 순서 규칙을 확장하여 더 향상된 동시성을 제공한다.

			[스케줄 A]
			Ti       |   Tj
			read(Q)  |
			         |  write(Q)
			write(Q) |

타임스탬프 순서 규칙을 따른다면, $T_i$가 write(Q)를 하는 시점에서 $TS(T_i)$ < W-timestamp(Q)이므로 Ti는 롤백되어야 한다. $T_i$의 롤백은 새로운 타임스탬프를 부여할 것이고, $T_i$는 다시 read(Q)와 write(Q)를 수행할 것이다. 최종적으로 결과에는 $T_i$의 쓰기 결과가 데이터베이스에 반영되어 있을 것이다. 이는 $T_j  T_i$ 순서대로 직렬 실행된 것과 동일한 결과를 갖는다. 시작 시점에서는 $T_i$가 더 앞선 타임스탬프를 가졌지만, 이것은 롤백에 의해 변경되었으므로 타임스탬프 순서로 직렬 수행된 합당한 결과를 갖는다.

하지만 만약 다음과 같이 수행되었다면 어떨까?

			[스케줄 B]
			Ti       |   Tj
			read(Q)  |
			write(Q) |
			         |  write(Q)

이 스케줄도 충분히 가능한 스케줄이며, 타임스탬프 순서 규칙에 위배되지 않는다. 이 스케줄의 수행은 $T_j$의 쓰기 결과가 최종적으로 데이터베이스에 반영되며, $T_i$의 쓰기는 무시된다. TS($T_i$) < TS($T_j$)이며, 타임스탬프 순서에 의한 직렬성을 보장한다.

그렇다면 다시 돌아가서, **스케줄 A에서 $T_i$를 롤백할 필요가 있는가?** 엄밀히 말하면 그렇지 않다. 왜냐하면 $T_j$는 이미 Q에 쓰기를 끝낸 상태이고, $T_i$가 덮어쓰려고 하는 값은 그 뒤에 실행되는 트랜잭션이 읽을 필요가 없는 값이기 때문이다. 합당한 스케줄인 스케줄 B에서 $T_i$의 write(Q)가 무시될 수 있음을 생각하면 이해하기 쉽다. 이는 오히려 롤백으로 인해 불필요한 리소스를 사용하게 되는 것이다.

토마스의 쓰기 규칙은 이러한 상황에서 쓰기 연산을 무시하도록 타임스탬프 시간 규약을 확장한다. 트랜잭션 $T_i$가 write(Q)를 수행할 때 다음과 같은 로직을 수행해야 한다.

1. TS($T_i$) < R-timestmap(Q)라면, $T_i$가 쓰려는 값은 더 나중에 실행된 트랜잭션이 읽은 값이므로 시스템은 $T_i$가 값을 기록하는 것을 허용하지 않는다. 시스템은 write 연산을 거절하고 $T_i$를 롤백한다.
2. **TS($T_i$) < W-timestamp(Q)라면, $T_i$보다 나중에 실행된 트래잭션이 이미 Q를 갱신하였으므로 $T_i$가 쓰려고 하는 값은 쓸모없는 값이다. 따라서 이 쓰기 연산은 무시된다.**
3. 나머지 경우라면 write 연산은 실행되고 W-timestamp(Q)는 TS($T_i$)로 설정된다.

쓸모없는 쓰기 연산을 무시함에 따라 **토마스의 쓰기 규칙은 충돌 직렬 가능성을 보장하지 못한다.** 하지만 그 결과가 올바른 스케줄임은 분명하다. 이와 같이 충돌 직렬 불가능하지만 올바른 스케줄에 대해 **뷰 직렬 가능**(view serializable) 개념을 적용할 수 있다.