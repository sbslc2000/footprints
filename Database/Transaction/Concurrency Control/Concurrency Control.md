---
상위 개념: "[[../Transaction|Transaction]]"
---
# 동시성 제어
데이터베이스는 다음의 조건을 보장할 수 있는 매커니즘을 제공해야 한다.
* 모든 가능한 스케줄이 [충돌 직렬 가능](../Serializability/Conflict%20Serializability.md) 또는 뷰 직렬 가능이어야 한다.
* [복구 가능](../Schedule/Recoverable%20Schedule.md)하고, 가급적 [비연쇄적](../Schedule/Cascadeless%20Schedule.md)이어야 한다.
* 동시 실행을 허용해야 한다.

하지만 스케줄이 이미 실행된 이후 직렬 가능성을 검사하는 것은 너무 늦는다. 동시성 제어의 목표는 스케줄이 실행되기 전에 직렬 가능성을 보장하는 것이다. 

동시성 제어 프로토콜은 우선순위 그래프가 만들어지는 과정을 직접 검사하지 않으며, 그 대신 비직렬가능 스케쥴이 생성되지 않도록 일정한 규율을 적용한다.

서로 다른 동시성 제어 프로토콜은 허용하는 동시성 수준과 발생하는 오버헤드 사이에 서로 다른 절충점을 제공한다. 강한 수준의 일관성을 요구한다면 동시성 수준은 떨어질 것이며, 높은 동시성 수준을 필요로 한다면 약한 일관성을 갖게 될 수 있다. 일부 애플리케이션은 정확한 값을 사용할 필요가 없을 수도 있으므로, 이런 경우 정확성을 포기하고 성능을 향상시키는 동시성 제어 방식을 사용하는 것은 유의미한 선택일 수 있다.

## 동시성 제어가 필요한 이유
동시성 제어를 하지 않고 다수의 트랜잭션을 동시에 수행한다면 다음과 같은 문제가 발생할 수 있다.
* **갱신 손실**(lost update): 수행 중인 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어 씀으로써 갱신이 무효가 되는 것
* **오손 데이터 읽기**(dirty read): 완료되지 않은 트랜잭션이 갱신한 데이터를 읽는 것
	* ex. T1이 A의 잔액을 100,000원 감소시킨 후, T2는 모든 계좌의 잔액의 평균값을 계산했다. 이후 어떠한 이유로 T1이 철회된다면, T2의 결과 평균값은 잘못된 데이터가 된다.
* **반복할 수 없는 읽기**(unrepeatable read): 한 트랜잭션이 동일한 데이터를 두 번 읽을 때 서로 다른 값을 읽는 것
	* ex. T2는 모든 계좌 잔액의 평균을 검색했다. T2가 종료되기 전, T1은 A의 잔액을 100,000원 감소시키고 완료되었다. 이후 T2가 다시 평균값을 검색하면 처음 읽었던 값과 다른 값을 보게 된다.

갱신 손실 혹은 오손 데이터 읽기는 일관성에 문제가 발생하지만, 반복할 수 없는 읽기의 경우 엄밀히 따진다면 오류가 있는 것은 아니다.