---
상위 개념: "[[../Concurrency Control|Concurrency Control]]"
---
# Lock
잠금은 데이터 항목에 상호 독점적, 혹은 배타적으로 접근하도록 동시 액세스를 제어하는 매커니즘이다.

모든 트랜잭션은 데이터 항목 Q에 대해 어떤 연산을 수행할지에 따라 적절한 모드의 잠금을 동시성 제어 관리자에게 요청(request)해야한다. 이 요청에 따라 동시성 관리 제어자가 해당 트랜잭션에 요청한 잠금을 허용(grant)했을 때 트랜잭션은 자신의 연산을 계속 진행할 수 있다.

## Compatibility
데이터 항목 Q에 대해 만약 $T_j$가 B 모드의 잠금을 가지고 있을 때, $T_i$가 A 모드의 잠금을 얻을 수 있는 경우 A와 B는 서로 호환(compatible)된다고 말한다.

예를 들어 공유 모드의 잠금은 다른 공유 모드의 잠금과는 호환성을 가지지만, 독점적 모드의 잠금과는 호환성을 가지지 않는다.

만약 $T_i$가 어떤 항목에 접근하고자 잠금을 걸려고 하는데 만약 다른 트랜잭션에서 해당 항목에 대해 비호환적인 잠금이 걸려있다면, 동시성 관리 제어자는 해당 항목에 걸려있는 모든 비호환적인 잠금이 해제될 때까지 $T_i$의 잠금 요청을 허용하지 않는다. $T_i$는 대기(wait)해야한다.

## Deadlock
만약 $T_1$이 데이터 항목 A에 대한 독점 락을 가진 상태로 B에 대한 독점 락을 얻기를 원할 때, $T_2$가 이미 B에 대한 독점 락을 가지고 있으면서 A에 대한 독점 락을 얻고자 하는 경우에는 두 트랜잭션 모두 잠금을 얻기 위해 계속 기다리는 문제가 발생할 수 있다. 이러한 상태를 교착 상태(deadlock)이라고 한다.

교착 상태가 발생하면 시스템은 두 트랜잭션 중 하나를 롤백해야 한다. 일단 한 트랜잭션이 롤백되면 가지고 있던 잠금이 모두 해제되기 때문에 다른 트랜잭션이 원하던 잠금을 얻어 다음 연산을 실행할 수 있게 된다.

## Starvation
만약 $T_1$이 A에 대한 독점 락을 가지기 위해서 $T_2$의 공유 락 해제를 기다리고 있다고 하자. 이 때에 $T_3$이 A에 대한 공유 락을 갖기를 원하는 경우 해당 잠금은 허용된다. $T_2$가 종료되더라도, $T_3$이 공유락을 가지고 있으므로 $T_1$은 여전히 대기하게 된다. 이러한 상황은 반복될 수 있다.

이렇게 특정 자원을 점유하기를 원하나 계속 대기하는 상태를 기아 상태(starvation)이라고 한다. 이는 다음과 같은 방법으로 피할 수 있다.

```
트랜잭션 T가 특정 모드 M으로 데이터 항목 Q에 대한 잠금을 요청할 때, 동시성 제어 관리자는 다음 두 가지 경우에 한해 잠금을 허용해 준다.

1. M과 충돌되는 잠금 모드로 Q에 잠금을 걸고 있는 다른 트랜잭션이 없다.
2. T보다 먼저 Q에 잠금을 요청해서 기다리고 있는 트랜잭션이 없다.
```

## Locking Protocol
잠금 규약(locking protocol)은 트랜잭션이 데이터 항목에 언제 잠금을 걸고 해제할 수 있는지에 대한 일련의 규칙이다. 잠금 규약의 종류에 따라 가능한 실행 스케줄은 달라질 수 있다. 
