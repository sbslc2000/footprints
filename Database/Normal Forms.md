---
상위 링크: "[[Database]]"
---
# 정규화

데이터베이스 정규화란 릴레이션의 구조를 중복이 적게 만들면서 데이터를 가져오기 쉬운 좋은 구조로 만드는 과정입니다. 여기서 좋은 구조란 무엇일까요? 어떠한 데이터 구조가 다른 데이터 구조보다 좋다는 기준이 뭘까요? 이것을 측정할 수 있을까요? 선대 개발자들은 이것을 측정가능한 단계로 나누었으며, 이것은 각각의 정규화 단계로 규정되어 왔습니다.

![](https://i.imgur.com/HzrCVwL.png)

NF 는 Normal Form (정규화 형태) 의 약자입니다. 이 이후로부터는 각각의 정규화 단계가 어떤 구조이며, 이 구조가 어떤 문제를 해결하는지에 대해 알아볼 예정입니다. 그 전에, 정규화를 이해하기 위해서 어떠한 데이터 구조가 나쁜지에 대해서 알아야합니다. 또한 정규화에 대해 설명할 때에 선행되어야 되는 개념들이 있어서 이것들을 먼저 설명하도록 하겠습니다.

## Data Anomaly

데이터베이스를 잘못 설계하면 불필요한 데이터 중복이 발생하여 릴레이션에 대한 데이터의 삽입, 수정, 삭제 연산을 수행할 때 부작용들이 발생할 수 있습니다. 이러한 부작용을 이상 현상_Data Anomaly_이라고 합니다. 이상 현상을 제거하면서 데이터베이스를 올바르게 설계해 나가는 과정이 정규화 과정입니다.

### Insert Anomaly
삽입 이상은 새로운 데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입해야하는 문제를 일컫는 용어입니다.

![](https://i.imgur.com/A81Y1we.png)

위 릴레이션에 아래와 같은 투플을 넣으려고 합니다. 아래 삽입하려는 투플은 의미적으로 Course Code가 존재할 수 없는 상황이라고 가정합니다. 이러한 경우에 새 투플을 삽입하기 위해서는 Course Code의 값을 강제로 넣어줘야합니다. 아마 NULL 값을 넣게 될 것입니다. 데이터베이스가 잘 설계되어있지 않다면, 어떠한 투플을 삽입할 때 해당 투플에 의미적으로 맞지 않는 속성이 들어갈 수 밖에 없습니다. 엄밀히 말하면 삽입되는 투플은 Course Code가 NULL이라는 의미가 아닙니다. 값이 NULL인 것과 속성이 존재하지 않는 것은 다른 의미를 가지기 때문입니다. 이러한 문제를 삽입 이상이라고 부릅니다.

### **Update Anomaly**

변경 이상은 부분적 수정에 대한 위험을 이르는 말입니다.
![](https://i.imgur.com/9WMMXIR.png)

위 릴레이션에서 519번 Employee는 하나의 Employee Address만을 가져야 합니다. 하지만 519번 Employee가 2개의 Skill을 가지고 있기 때문에, 원자성에 의해 2개의 투플로 분리되었고, 따라서 2개의 Employee Address 값이 DB에 유지되고 있습니다. 이 경우 두 값에 대해 의미적 연결은 존재하지만 논리적 연결은 존재하지 않기 때문에, 둘중 하나의 값이 변경되어도 DB는 문제를 일으키지 않지만 의미적으로는 중대한 문제가 발생합니다. 위 테이블은 519번 Employee의 Address가 모종의 이유로 부분적 수정이 되어 서로 다른 값을 갖고있는 상황을 보여줍니다. 두 값이 모두 수정된다면 문제가 없겠지만, 이러한 구조는 언제나 부분적 수정으로 인하여 데이터 무결성이 깨질 위험을 갖고 있습니다. 이러한 문제를 변경 이상이라고 부릅니다.

### **Delete Anomaly**

삭제 이상은 삭제로 인해 발생하는 데이터의 이상현상을 의미합니다.
![](https://i.imgur.com/InKHbAe.png)

위 릴레이션에서 389번에 해당하는 Faculty를 삭제하려고 합니다. 하지만 389번 Faculty를 삭제하기 위해서는 그 Course Code 속성도 함께 삭제됩니다. 이 경우 ENG-206이라는 Course Code는 데이터베이스 상에서 삭제되어 찾을 수 없게 됩니다. 이는 삭제자가 의도했던 바가 아닙니다. 이러한 문제를 삭제 이상이라고 합니다.

Anomaly 가 발생하는 이유는 관련이 없는 데이터, 즉 속성들을 하나의 릴레이션에 모아두고 있기 때문입니다. Anomaly 가 발생하지 않도록 하려면, 관련있는 속성들로만 릴레이션을 구성해야 하는데 이를 위해 필요한 것이 정규화입니다.

정규화는 anomaly가 발생하지 않도록, 릴레이션을 관련이 있는 속성들로만 구성하기 위해 릴레이션을 분해_decomposition_ 하는 과정입니다. 정규화를 수행하려면 먼저 릴레이션을 구성하는 속성들 간의 관련성을 판단할 수 있어야합니다. 정규화 과정에서 고려해야 하는 속성들 간의 관련성을 함수적 종속성_FD : Functional Dependency_라고 합니다. 일반적으로 릴레이션에 함수적 종속성이 하나만 존재하도록 정규화를 통해 릴레이션을 분해하게 됩니다.

## Lossless Decomposition

Decomposition은 분해입니다. Lossless Decomposition은 손실 없는 분해입니다. 데이터베이스를 설계하다보면 여러 이유로 릴레이션을 분리해야할 때가 있습니다. 이는 각 릴레이션의 관심사를 좀 더 세분화하여 분리해야하기 위함일 수도 있고, 중복된 데이터를 없애기 위해 분리할 수도 있습니다. 여러 이유로 릴레이션을 분리할 필요가 있는데, 아무런 규칙 없이 릴레이션을 분리하면 데이터 손실 혹은 중복이 발생합니다.
![](https://i.imgur.com/uegc5Lj.png)

어떤 기준으로 릴레이션을 분리해야 원본의 릴레이션을 그대로 복구할 수 있을까요? 나중에 분리된 릴레이션을 합쳤을 때 손실 혹은 중복이 없게 하기 위해서는 함수적 종속성이 있는 속성들을 기준으로 분리해야합니다. 함수적 종속성에 대해서는 아래에서 알아보겠습니다.

## Functional Dependency

함수적 종속성은 데이터베이스에서 속성들 간의 관계를 나타내는 개념입니다. 한 속성 또는 속성 집합의 값에 의해 다른 속성 또는 속성 집합의 값이 유일하게 결정되는 경우, 이를 함수적 종속성이 있다고 합니다. 이를 표현할 때는 X → Y로 표기하며, X를 결정자*Determinant*라고 하고 Y를 종속자*Dependent*라고 합니다.

![](https://i.imgur.com/I7XcoBy.png)


위 릴레이션에서 name은 dept_name 에 대하여 함수적 종속성을 갖습니다. (name → dept_name) name의 값에 따라서 dept_name이 유일하게 결정되기 때문입니다. 반면 dept_name → name 은 함수적 종속성을 갖지 않습니다. dept_name의 값 중 Physics에 대해서는 name의 값이 유일하게 결정되지 않기 때문입니다(James와 Tom이 올 수 있음).

위 릴레이션에서 name→ salary 는 함수적 종속성을 갖습니다. salary → name 역시 함수적 종속성을 갖습니다. 하지만 이 관계는 앞으로도 쭉 함수적 종속성을 가질까요? 그렇지 않을 것입니다. 5번 투플에 {5, Seo, Comp.Sci. , 95000} 의 투플이 들어온다면 salary 는 name에 대해서 함수적 종속성을 갖지 못합니다. FD 를 판단할 때에 유의할 점은, 현재 시점에 릴레이션에 포함된 속성 값만으로 판단하면 안된다는 점입니다. 릴레이션에서 속성 값은 계속 변할 수 있기 때문에 속성 자체가 갖고 있는 특성과 의미를 기반으로 판단해야합니다.

id 는 {name, dept_name, salary}에 대해서 함수적 종속성을 갖습니다. 이렇게 하나의 속성 혹은 속성 집합이 나머지 속성 집합에 함수적 종속성을 갖는다면 전자의 속성들은 후보키가 될 수 있습니다.

### Fully Functional Dependency

Fully Functional Dependency, FFD 는 릴레이션에서 속성 집합 Y가 속성 집합 X에 함수적으로 종속되어있지만, 속성 집합 X의 전체가 아닌 일부분에는 종속되지 않음을 의미합니다.

### Partial Functional Dependency

PFD는 속성 집합 Y가 속성 집합 X의 전체가 아닌 일부분에도 함수적으로 종속됨을 의미하므로, 부분 함수 종속 관계가 성립하려면 결정자가 여러개의 속성들로 구성되어 있어야 합니다.

FFD 와 PFD의 개념을 읽기만 한다면 무슨 이야기를 하는지 와닿지 않을 겁니다. 아래 예시를 보고 위 문장들을 다시 곱씹어 본다면 어렵지 않게 이해할 수 있을 겁니다.

### FFD and PFD 예시

GRADE = F(ID,COURSE_ID)
![](https://i.imgur.com/OwzaaG9.png)


위에 있는 테이블은 학생 ID와 학년, 수강과목과 점수를 담고 있는 릴레이션이고, 아래 다이어그램은 속성 간의 연결관계를 표현한 다이어그램입니다.

ID와 COURSE_ID 속성의 집합은 SCORE라는 속성에 대해 Functional Dependency를 갖습니다. 또한 이 관계는 Fully Functional Dependency 관계인데, 그 이유는 속성 {ID, COURSE_ID} 가 속성 {SCORE}에 대해 FD를 갖고 있으면서, {ID,COURSE_ID} 집합의 부분집합인 {ID} 나 {COURSE_ID} 는 {SCORE}과 FD를 갖지 않기 때문입니다.

{ID,COURSE_ID}는 {GRADE}에 대해 Functional Dependency를 갖습니다. 이 관계는 Partial Functional Dependency인데, 그 이유는 {ID,COURSE_ID}의 부분집합인 {ID} 가 {GRADE}와 FD를 갖기 때문입니다.

## Lossless Decomposition and Functional Dependency

릴레이션 R이 R1과 R2로 분리된다고 했을 때, 이 분리가 Lossless Decomposition, 즉 합쳤을 때 손실이나 중복이 없게 하기 위해서는 R1과 R2의 교집합 속성이 R1이나 R2에 Functional Dependency를 가져야 합니다.

### Example

$R = \{ A, B, C\}$

$FD= \{ A \rightarrow B, B \rightarrow C \}$

$R_1 = \{ A,B \} , R_2 = \{B,C\}$

$R_1 \cap R_2 = \{B\}$

함수적 종속성의 성질 ( if {X}→{Y}, then {X} → {X,Y} ) 로 인해 B → {B,C} 가 성립하므로

위 R1, R2로 분해하는 것은 Lossless Decomposition입니다.

## Normal Forms

이제는 정규화를 좀 더 학술적인 용어로 설명할 수 있게 됐습니다. 정규화란 릴레이션의 Functional Dependency를 이용하여 연관성이 있는 속성들로만 구성되도록 Lossless Decomposition을 해서, Anomaly가 발생하지 않는 Good Form으로 만들어나가는 과정을 의미합니다.

정규화의 기본 목표는 관련성이 없는 FD는 별개의 릴레이션으로 표현하는 것입니다. 각 정규화의 모든 과정에서 FD를 갖는 릴레이션의 속성들을 분리하는 과정을 거치게 됩니다.

릴레이션이 정규화된 정도는 정규형_Normal Form, NF_으로 표현합니다. 각 정규형마다 만족시켜야하는 제약조건이 존재합니다. 아래부터는 각 정규형이 만족해야하는 제약조건에 대해 설명합니다.

## 제 1 정규형

> 릴레이션에 속한 모든 속성의 도메인이 원자값으로만 구성되어있어야 한다.All attributes should have a single value.



![](https://i.imgur.com/rx19oLu.png)

## 제 2 정규형

> 릴레이션이 제 1 정규형에 속하고, PK가 아닌 모든 속성이 PK에 Full Functional Dependency를 가져야한다. All non-PK attributes should be fully functional dependent on the entire PK.

![](https://i.imgur.com/6DitmZD.png)

위 릴레이션에서 투플을 특정할 수 있는 PK는 {학생번호,과목} 속성 집합입니다. {학생번호,과목} 을 지정하면 해당 학생이 해당 과목에서 어떤 교수에게 강의를 들었으며 몇 점을 받았는지 확인할 수 있습니다.

하지만 위 릴레이션은 제 2 정규형에 속하지 않습니다. 제 2 정규형에 속하려면 PK가 아닌 모든 속성 {지도교수}, {성적} 이 PK에 FFD를 가져야 하는데, 위 릴레이션에서 성적은 PK에 대해 FFD 를 갖지만 지도교수는 PK의 부분집합인 과목에 FD를 갖기 때문입니다. {학생번호,과목} 은 {지도교수}에 PFD를 갖습니다. 따라서 제 2 정규형을 만족시키기 위해서는 PFD를 갖는 과목 - 지도교수 속성을 별도의 릴레이션으로 분해해야합니다. 아래는 분해 이후의 릴레이션 상태입니다.

![](https://i.imgur.com/9ZQFIxC.png)

두 릴레이션의 교집합인 {과목}은 우측 릴레이션에 FD를 가지므로 Lossless Decomposition이 만족됩니다. 이제 릴레이션은 2개가 됐으므로 두 릴레이션이 어느정도의 정규화 정도를 만족하고있는지 확인해야합니다.

첫번째 릴레이션은 모든 값이 원자로 이루어져있으므로 제 1 정규형을 만족합니다. 또한 PK가 NON-PK인 모든 속성에 대해서 FFD를 가지므로 제 2 정규형 또한 만족합니다.

두번째 릴레이션은 모든 값이 원자로 이루어져있으므로 제 1 정규형을 만족합니다. 또한 PK가 Non-PK인 모든 속성에 대해 FFD를 가지므로 제 2 정규형 또한 만족합니다.

하지만 이 예시는 완전하지는 않아 보입니다. 이러한 예시는 한 과목을 무조건 하나의 지도교수가 가르친다 라는 가정 하에서 완전해 보입니다. 만약 운영체제의 지도교수 박재현이 있었다면 추가적인 분리가 이루어져야 할 것입니다. 우측의 PK인 과목이 지도교수에 대해 FD를 갖지 못할 것이기 때문입니다.

## 제 3 정규형

> 릴레이션이 제 2 정규형에 속하고, PK가 아닌 모든 속성이 PK에 이행적 함수 종속*Transitive Dependency*이 되지 않아야 한다. All non-PK attributes should not be dependent on other non-PK attributes.

이행적 함수 종속이란 A→B, B→C 일때, A→C가 성립하는 경우를 의미합니다. 이 문장은 영문을 봤을때 이해하기 훨씬 수월하리라 생각합니다.

![](https://i.imgur.com/kqg4V82.png)

사용자 ID와 사용자의 등급, 그리고 등급에 해당하는 할인율을 갖고있는 릴레이션입니다. 우측은 속성 간 FD를 표현한 다이어그램입니다. 위 릴레이션을 분석해보도록 하겠습니다.

모든 속성이 원자값을 가지므로 위 릴레이션은 제 1 정규형을 만족합니다.

PK가 아닌 모든 속성이 PK에 대해 FFD를 가지는 것으로 보입니다. 위에서 언급했듯이 PFD는 Determinant가 두개 이상에 속성을 보유하고 있을 때 적용될 수 있는 개념이기 때문입니다. {ID}의 부분집합은 공집합을 제외한다면 {ID} 밖에 존재하지 않고, ID를 통해 하나의 등급과 할인율만 결정될 수 있기 때문입니다. 따라서 위 릴레이션은 제 2 정규형을 만족합니다.

제 3 정규형을 따르려면 모든 non-PK 속성이 다른 non-PK 속성에 대해 FD를 가지면 안됩니다. 하지만 위 릴레이션의 경우 non-PK인 등급에 대해 non-PK인 할인율 속성이 FD를 갖고 있습니다. 따라서 위 릴레이션은 제 3 정규형에 위배됩니다. 이러한 문제를 해결하기 위해서 또 분리해야됩니다.

![](https://i.imgur.com/jiV44vm.png)

각각의 릴레이션은 제 1 정규형, 제 2 정규형을 만족합니다. 또한 기존의 non-PK → non-PK FD를 서로 다른 릴레이션으로 분리해서, 이제는 제 3 정규형을 만족하는 릴레이션 집합이 됐습니다.

> ❓ **정규화를 하면 뭐가 좋은가요?**
> 정규화를 통해 여러 Data Anomaly를 없앨 수 있습니다. 가령 위 릴레이션에서 정규화 되기 이전에 100명의 유저가 VIP 등급이라고 생각해 봅시다. 만약 VIP의 할인율이 40%에서 35%로 줄어든다면 릴레이션에 있는 100개의 VIP에 해당하는 할인율의 값을 다 변경해주어야 합니다. 이러한 과정은 Update Anomaly를 발생시키게 됩니다. 하지만 제 3 정규형을 만족하는 릴레이션에는 우측 릴레이션의 40%에 해당하는 값 하나만 35%로 바꿔준다면 모든 VIP 들이 변경된 할인율을 사용할 수 있게 됩니다. 이렇게 정규화를 통해서 Data Anomaly 들을 줄여나갈 수 있습니다.


## BCNF 정규형

BCNF 정규형는 정규형의 개념을 정리한 Boyce와 Codd의 이름을 딴 정규형입니다.

> 릴레이션이 제 3 정규형을 만족하고, 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키이면 BCNF 정규형에 속한다. All determinants should be candidate keys.

BCNF 정규형을 만족시키기 위해서는 모든 결정자가 후보키여야 합니다. 이 말은 즉슨 후보키에 존재하지 않는 속성이 결정자가 되어서는 안된다는 뜻입니다.

![](https://i.imgur.com/bu86LUl.png)

위 릴레이션을 분석해봅시다. 위 릴레이션은 {학생번호, 과목}을 PK로 갖는 릴레이션입니다. 101번 학생의 자바 과목 수강에 대해서는 김자바교수님이 지도하고 있습니다. 김자바 교수님은 또한 자바를 수강하는 104번 학생의 지도교수이기도 합니다. 반면 102번 학생은 오자바 교수님의 강의를 수강하고 있습니다. 이 릴레이션을 통해서 학생들이 듣는 강의의 교수님이 누구인지 알 수 있습니다.

제 1 정규형은 만족하는 것으로 보입니다.

모든 non-PK가 PK에 대해 FFD여야 한다는 제 2 정규형을 만족하는 것으로 보입니다. 위 릴레이션의 지도교수는 PK의 부분집합인 {학생번호}나 {과목}에 의해서 결정되지 않습니다.

모든 non-PK가 다른 non-PK에 FD를 갖지 않아야 한다는 제 3 정규형도 만족하는 것으로 보입니다. non-PK 는 지도교수 하나밖에 없습니다.

위 릴레이션에서 {지도교수}는 릴레이션의 후보키가 아닙니다. 후보키가 되려면 해당 속성을 통해 투플을 특정할 수 있어야 하기 때문입니다. 하지만 위 경우 ‘김자바 교수님’을 통해 특정 투플을 결정해낼 수 없으므로 {지도교수}는 후보키가 아닙니다.

하지만 {지도교수}는 {과목}에 대해 FD를 갖습니다. 지도교수를 특정한다면 과목을 결정할 수 있습니다. (물론 이것은 지도교수가 하나의 과목만 가르친다는 가정하에 성립합니다.) 이 경우 지도교수는 후보키가 아닌 상황에서 FD의 결정자가 됩니다. 이러한 상황은 BCNF 정규형에 위배됩니다.

![](https://i.imgur.com/YcLjsbS.png)

BCNF 정규형을 만족시키기 위해서는 위와 같이 분리하면 됩니다. 이제 릴레이션 내의 모든 결정자는 해당 릴레이션의 후보키에 해당합니다.

## 그 외 정규형

![](https://i.imgur.com/R2myFO9.png)

- **4NF**
    - All determinants in every non-trivial multivalued dependencies should be superkeys
- **5NF (Project-Join Normal Form)**
    - All non-trivial join dependency is implied by the candidate keys

BCNF 보다 더 정규화를 진행할 수 있습니다. 하지만 이 이상으로 정규화를 진행한다면 복잡성에 의해 효율성이 떨어지는 상황이 발생할 수 있습니다. 현업에서는 보통 3NF, BCNF의 정규형을 만족하는 것을 목표로 정규화를 진행한다고 합니다.