---
상위 개념: "[[Ordered Index]]"
---
# B+Tree Index
B+트리 인덱스 구조는 데이터의 삽입과 삭제에도 불구하고 성능을 유지하는 몇몇 인덱스 구조 중 가장 널리 사용된다. 

## B+트리 구조
![](https://i.imgur.com/iZF5j8l.png)

B+트리의 노드 구조는 위와 같다. P는 포인터이고, K는 검색키이다. 노드의 n-1개의 검색 키 값은 정렬된 순서로 유지된다. i  < j 라면 $K_i$ < $K_j$ 이다.

만약 노드가 단말 노드(leaf node)라면, $P_i$ 는 $K_i$ 검색 키를 갖는 레코드를 가리킨다. 만약 내부 노드라면, $P_i$는 $K_{i-1}$ 보다 크거나 같으면서 $K_i$ 보다 작은 검색 키를 포함하는 서브트리를 가리킨다. 내부 노드는 항상 트리에 대한 포인터를 가지고, 실제 데이터 접근은 항상 리프 노드에서 수행한다.

![](https://i.imgur.com/EDa2fG4.png)

위 그림에서 첫번째 내부노드의 Einstein 이라는 키를 기준으로 좌측 포인터는 Einstein보다 작은 검색키를 가진 서브트리이고, 우측 포인터는 Einstein보다 크거나 같으면서 Gold보다 작은 검색키를 가진 서브트리이다.

루트 노드를 제외한 각각의 노드는 최소 $\lceil n / 2 \rceil$  개의 값을 포함해야 하며, $n-1$ 개 까지의 값을 가질 수 있다. 이 때 포인터의 개수인 n을 팬아웃(fanout)이라고 부른다. 루트 노드는 상황에 따라 1개의 값을 가질 수 도 있다.

단말 노드의 마지막 포인터 ($P_n$)은 검색 키 순서로 다음 노드를 가리킨다. 노드 간에도 정렬이 되어 있으므로, $P_n$을 통해 자연스레 다음 검색키를 가진 값들로 선형 탐색을 수행할 수 있다.

## 왜 B+트리 인덱스를 사용하는가?
1. **트리의 높이가 낮다.**
B+트리의 노드 크기는 일반적으로 디스크 블록의 크기를 가지며, 따라서 한 노드에 여러 검색키를 넣을 수 있기에 트리의 형태가 굵고 짧게 구성된다. 1,000,000개의 데이터 중 특정 값을 찾는데에도 4개의 노드만 읽으면 충분하다.

2. **범위 질의에 용이하다.**
각 말단 노드의 마지막 포인터는 다음 검색키를 가진 노드를 향하고 있다. 클러스터링 인덱스의 경우 말단 노드를 넘어 데이터를 탐색하더라도 레코드가 연속된 곳에 위치하기 때문에 디스크 탐색은 1회만 발생한다. 

3. **데이터의 삽입과 삭제에도 국소적으로 재조정이 일어난다.**

