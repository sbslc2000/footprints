---
상위 개념: "[[B+Tree Insert Operation]]"
---
# B+Tree Insert Operation
하나의 노드에는 유지될 수 있는 검색키의 개수가 제한되어있으므로, 검색키가 늘어난다면 노드를 분할해야할 필요가 생긴다. 이 과정은 균형을 깨트리지 않는 로직으로 동작해야한다.

## 1. 단순 삽입
단순한 삽입이란 검색키를 삽입하는 것이 노드의 분할이나 트리의 재구조화를 요구하지 않는 삽입이다.검색키를 따라가 삽입되어야 할 단말 노드를 찾고, 해당 노드 내에 엔트리를 생성한다.

![](https://i.imgur.com/OuEyVZR.png)
*삽입 전*
![](https://i.imgur.com/9tUtkdt.png)
*삽입 후*

일반적으로 갱신에서 분할이 일어날 가능성은 매우 낮아서, 대부분이 이 로직대로 동작한다. 

## 2. 단말노드 분할
단말노드에 여유공간이 없는 경우 분할을 해야한다. n개의 검색 키 값을 가질 때, 처음 $\lceil n/2\rceil$개는 원래 존재하는 노드에 두고, 나머지는 새로운 노드에 놓는다.

위 트리에서 'Adams'를 넣어보자.
![](https://i.imgur.com/E70WaKw.png)
첫번째 단말노드가 넘쳤으므로 분할해야한다. 첫 2개는 원래의 노드에 놓고, 나머지 2개의 노드를 새로운 노드로 만들자.
![](https://i.imgur.com/1psskH9.png)

새롭게 생성된 단말 노드를 B+트리 구조에 삽입해야 한다. 새롭게 생성된 노드는 가장 작은 검색키 값으로 Califieri를 가진다. **이 검색키 값을 가진 엔트리**와 **새로운 노드를 가리키는 포인터**를 분할된 단말 노드의 부모에 삽입해야 한다.
![](https://i.imgur.com/b4fXDgl.png)
이 때도 부모에 자리가 없었다면 추가적인 노드 분할이 발생했겠지만, 지금의 케이스에서는 다행히 부모 노드에 자리가 있었다. 이제 리프 노드간의 순차 연결 포인트를 업데이트하면 삽입 동작은 끝난다.
![](https://i.imgur.com/kL46oET.png)
## 3. 비단말 노드 분할
'Lamport'를 삽입해보자.
![](https://i.imgur.com/WtL241B.png)
단말 노드가 가득 찼으니 2번의 규칙을 따라 노드를 분할한다.
![](https://i.imgur.com/U0SEZUf.png)
새로 생성된 노드의 가장 작은 검색키 값과 포인터 값을 갖는 엔트리를 부모에 넘겨주자.
![](https://i.imgur.com/K0TalzA.png)
엔트리를 추가할 공간이 없어 부모 노드 역시 분할되어야 한다.

비단말 노드에서의 분할은 가운데 요소가 상위 노드로 승격함으로써 동작한다. 1번과 다르게 승격이라는 표현을 쓴 이유는, 단말 노드에서는 요소가 노드에 남아있으면서 단순히 해당 노드의 접근하는 엔트리를 '삽입'만 하지만, 비단말 노드에서는 요소가 상위로 이동하기 때문이다. 위 예제에서 Gold 엔트리는 Mozart가 있는 상위 노드로 올라간다. 기존의 Gold가 있던 공간을 기준으로 노드는 분할된다. 분할되며 새롭게 생긴 노드의 엔트리는 상위 노드로 승격한 엔트리가 가리키게 된다.
![](https://i.imgur.com/7ZQX0Ht.png)

더 이상 분할이 안 생길때 까지 재귀적으로 과정을 반복하면 삽입은 종료된다.