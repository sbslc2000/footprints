---
상위 개념: "[[B+Tree Insert Operation]]"
---
# B+Tree Insert Operation
하나의 노드에는 유지될 수 있는 검색키의 개수가 제한되어있으므로, 검색키가 늘어난다면 노드를 분할해야할 필요가 생긴다. 이 과정은 균형을 깨트리지 않는 로직으로 동작해야한다.

## 1. 단순 삽입
단순한 삽입이란 검색키를 삽입하는 것이 노드의 분할이나 트리의 재구조화를 요구하지 않는 삽입이다.검색키를 따라가 삽입되어야 할 단말 노드를 찾고, 해당 노드 내에 엔트리를 생성한다.

![](https://i.imgur.com/OuEyVZR.png)
*삽입 전*
![](https://i.imgur.com/9tUtkdt.png)
*삽입 후*

일반적으로 갱신에서 분할이 일어날 가능성은 매우 낮아서, 대부분이 이 로직대로 동작한다. 

## 2. 단말노드 분할
단말노드에 여유공간이 없는 경우 분할을 해야한다. n개의 검색 키 값을 가질 때, 처음 $\lceil n/2\rceil$개는 원래 존재하는 노드에 두고, 나머지는 새로운 노드에 놓는다.

위 트리에서 'Adams'를 넣어보자.
![](https://i.imgur.com/E70WaKw.png)
첫번째 단말노드가 넘쳤으므로 분할해야한다. 첫 2개는 원래의 노드에 놓고, 나머지 2개의 노드를 새로운 노드로 만들자.
![](https://i.imgur.com/1psskH9.png)

새롭게 생성된 단말 노드를 B+트리 구조에 삽입해야 한다. 새롭게 생성된 노드는 가장 작은 검색키 값으로 Califieri를 가진다. **이 검색키 값을 가진 엔트리**와 **새로운 노드를 가리키는 포인터**를 분할된 단말 노드의 부모에 삽입해야 한다.
![](https://i.imgur.com/b4fXDgl.png)
이 때도 부모에 자리가 없었다면 추가적인 노드 분할이 발생했겠지만, 지금의 케이스에서는 다행히 부모 노드에 자리가 있었다. 이제 리프 노드간의 포인터를 순서에 맞게 정리해주면 삽입 동작은 끝난다.
![](https://i.imgur.com/kL46oET.png)
## 3. 비단말 노드 분할
비단말 노드의 분할은 단말 노드와 약간 다르다. 'Lamport'를 삽입해보자.
![](https://i.imgur.com/WtL241B.png)
단말 노드가 가득 찼으니 2번의 규칙을 따라 노드를 분할한다.
![](https://i.imgur.com/U0SEZUf.png)
새로 생성된 노드의 가장 작은 검색키 값과 포인터 값을 갖는 엔트리를 부모에 넘겨주자.
![](https://i.imgur.com/K0TalzA.png)
엔트리를 추가할 공간이 없어 부모 노드 역시 분할되어야 한다.

비단말 노드에서 일어났던 일은, '새로 생성된 노드의 가장 작은 검색키값과 포인터를 부모 노드의 엔트리에 추가하자'였다. 하지만 비단말 노드는 이와 다르게 동작한다.

먼저, 
