---
상위 개념: "[[B+Tree Index/B+Tree Index]]"
---
# B+Tree Index Delete Operation
B+Tree 인덱스 삭제에서 주요하게 볼 개념은 노드 유착(coalescing)과 재분배(redistribute)이다.

## 노드 유착(coalescing)과 재분배(redistribute)
![](https://i.imgur.com/5cTpGzT.png)

위 인덱스에서 Srin을 삭제해보자. 검색키에 따라 단말 노드를 찾는다. Srin을 삭제하면 해당 단말 노드는 Wu 한 개의 값 만을 갖게 되므로, 단말 노드가 최소로 가져야 하는 값 조건에 위배된다.단말 노드는 적어도 $\lceil(n-1)/2\rceil$개의 값을 포함해야 하기 때문이다. 이 예제의 경우 2가 최소 개수가 된다. 이렇게 값이 부족해진 노드를 미달 노드(underfull)라고도 부른다. 미달 문제를 해결하기 위해 Wu의 엔트리를 왼쪽의 형제 노드로 움직여 합병하고, 비워진 오른쪽 형제 노드를 삭제한다.
![](https://i.imgur.com/LG6gQLN.png)

노드를 삭제하고 나니, 갈 길을 잃은 포인터와 부모 엔트리가 생겼다. 노드가 삭제되면 반드시 방금 삭제한 노드를 가리키는 부모 노드 역시 삭제해야 한다. 허나 이 노드를 삭제하면, 비단말 노드는 최소 $\lceil n /  2\rceil$ 개의 자식을 가져야 한다는 규칙에 어긋난다. 1개의 포인터만을 갖기 때문이다.

예제의 형제 노드를 살펴보면 유일한 노드는 \[Califieri, Einstein, Gold]를 갖는 비단말 노드다. 비단말 노드의 최소 포인터 수가 부족하다면 **가능한 경우 형제 노드와 유착(coalescing)시켜야 한다.**

하지만 형제 노드는 포인터를 4개 가지고 있고, 문제가 된 노드는 1개를 가지고 있기 때문에 단순히 유착시킬 수 없다. 이런 경우를 해결하는 방법은 **적어도 $\lceil n/2 \rceil$ 개의 자식 포인터를 가지도록 노드와 그 형제 노드 사이의 포인터를 재분배(redistribute)하는 것이다.** 재분배를 통해 형제 노드의 가장 오른쪽 포인터를 가져올 수 있다. 

![](https://i.imgur.com/GNYrUKK.png)
재분배를 통해 포인터를 옮긴 그림은 아래와 같다.
![](https://i.imgur.com/oqzXnDS.png)

Srin에 대한 값은 삭제되었으므로, 채워진 노드에서 기존에 있던 포인터와 재분배된 포인터를 구분하는 값은 존재하지 않는다. 이들을 구분하는 값은 부모노드에 존재하게 된다. 이 예제에서는 Mozart가 그 값이다.

재분배로 포인터를 옮겨왔다는 것은, 더 이상 부모의 노드에서 검색 키 값 구분이 정확하게 되지 않는 것을 의미하기도 한다. 따라서 검색키를 올바르게 분배하려면 부모 노드에 있는 Mozart 검색키는 빈 검색키를 채워야하고, 포인터를 넘겨준 Gold는 Mozart의 빈공간을 채우러 부모노드로 올라가야 한다.
![](https://i.imgur.com/0azBph1.png)

조금 더 알아보자. 위 결과에서, Singh와 Wu를 삭제한다. Singh를 삭제하는 것은 문제가 없었지만, Wu를 삭제하면 미달 노드가 된다. 왼쪽 형제 노드는 꽉 차있으므로 합쳐질 수 없다. 따라서 검색키 값 Kim을 Mozart위치로 옮기는 재분배가 수행된다. 결과적으로 아래와 같아진다.
![](https://i.imgur.com/CWYUr2o.png)
