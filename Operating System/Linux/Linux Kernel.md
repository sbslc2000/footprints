# Linux Kernel


## Linux Kernel Development
리눅스 커널은 일반적인 사용자 공간 애플리케이션과 비교했을 때 몇 가지 고유한 특성을 가진다. 

* 커널은 C 라이브러리나 표준 C 헤더에 접근할 수 없다.
* 커널은 GNU C로 작성되어 있다.
* 커널은 사용자 공간에서 제공되는 메모리 보호 기능을 가지고 있지 않다.
* 커널은 부동소수점 연산을 쉽게 실행할 수 없다.
* 커널은 프로세스마다 고정된 크기의 작은 스택만을 가진다.
* 커널은 비동기 인터럽트를 가지고, 선점형이며, SMP를 지원하기 때문에 동기화와 동시성이 중요한 고려사항이다.
* 이식성이 중요하다.

### Inline Function
```c
static inline void wolf(unsigned long tail_size)
```
C99와 GNU C는 인라인 함수를 지원하며, 커널 소스코드는 인라인 함수를 적극적으로 사용한다. 인라인 함수란 함수의 명령들이 별도의 함수 스택을 생성하지 않으며, 호출자의 코드에 복사되는 함수를 의미한다. 이는 함수의 호출-반환 (레지스터 저장과 복구)에 의한 오버헤드를 줄여주지만, 코드의 바이너리 크기가 증가하고 캐시 사용량이 증가한다는 단점이 있다.

### Inline Assembly
```c
unsigned int low, high;

asm volatile("rdtsc" : "=a" (low), "=d" (high));

/* low and high now contain the lower and upper 32-bits of the 64-bit tsc */
```
gcc C 컴파일러는 일반적인 C 함수 안에 어셈블리 명령어를 삽입하는 것을 가능하게 한다. 이 기능은 특정 시스템 아키텍처에 고유한 커널의 일부에서만 사용된다. 

어셈블리는 저수준 아키텍처 코드에 한정된다. 커널 코드의 압도적인 대다수는 순수 C로 작성된다.

### Branch Annotation
GCC C 컴파일러는 조건문을 최적화하는 내장 지시어를 갖고 있다. 이 지시어를 커널은 래핑하여 매크로로 만들어, likely()와 unlikeyly()로 제공한다.

```c
if (error) {
	/* ... */
}


// 만약 error가 거의 대부분 0일 경우, 즉, 거의 발생하지 않는 상황에 대해서
if (unlikely(error)) {
	/* ... */
}

// 만약 error가 거의 대부분 1일 경우, 즉, 거의 대부분 발생하는 상황에 대해서
if (likely(error)) {
	/* ... */
}
```
이는 예측에 실패하는 경우 상당한 성능 손실을 초래할 수 있다.

## No Memory Protection
유저 애플리케이션이 잘못된 메모리 접근을 시도하면, 커널은 그 오류를 감지하고 SIGSEGV 시그널을 보내 프로세스를 종료할 수 있다. 하지만 커널이 잘못된 메모리 접근을 시도하는 것은, oops 오류를 발생시키며 이는 커널 시스템이 패닉하고 종료되게 만들 수 있다.

또한 커널 메모리는 페이지 교환이 불가능하다. 따라서, 커널에서 사용하는 메모리의 모든 바이트는 사용 가능한 물리 메모리 공간을 항상 차지한다.

### No (Easy) Use of Floating Point
사용자 공간 프로세스가 부동소수점 명령을 사용할 때, 커널은 정수 모드에서 부동소수점 모드로의 전환을 관리한다. 사용자 공간과 달리, 커널은 스스로를 손쉽게 트랩할 수 없기 때문에 부동소수점을 매끄럽게 지원할 수 없다.

커널은 부동소수점 사용을 지양한다.

## Small, Fixed-size Stack
사용자 공간에서는 스택에 많은 변수를 정적으로 할당해도 괜찮은데, 이는 사용자 공간 스택이 충분히 크고, 또한 동적으로 늘어날 수 있기 때문이다.

하지만 커널의 스택은 크지도 않고 동적이지도 않다. 커널 스택의 정확한 크기는 아키텍처마다 다르다. x86의 경우, 스택 크기는 컴파일 시점에 설정할 수 있으며 4KB이거나 8KB이다.

### Synchronization and Concurrency
커널은 경쟁 상태에 취약하다. 단일 스레드 사용자 공간 애플리케이션과 달리, 커널의 여러 특성은 공유 자원에 대한 동시 접근을 필요로 하며 이를 위해 동기화가 필요하다.

* 리눅스는 선점형 멀티태스킹 운영체제이다. 프로세스들은 프로세스 스케줄러의 의도에 따라 스케줄된다. 커널은 이러한 작업들 사이에서 동기화를 수행해야한다.
* 리눅스는 대칭형 다중처리(SMP)를 지원한다. 따라서 두 개 이상의 프로세서에서 동시에 실행되는 커널 코드가 동일한 자원에 동시에 접근할 수 있다.
* 인터럽트는 현재 실행 중인 코드와는 비동기적으로 발생한다. 따라서 적절한 보호가 없다면, 어떤 자원에 접근하는 도중에 인터럽트가 발생할 수 있고, 그 인터럽트 핸들러가 같은 자원에 접근할 수 있다.
* 리눅스 커널은 선점형이다. 따라서 보호장치가 없다면, 커널 코드가 다른 코드에 의해 선점되어, 그 코드가 동일한 자원에 접근할 수 있다.

### Portability
사용자 애플리케이션과 다르게, 리눅스는 이식 가능한 운영체제이며 앞으로도 그래야 한다. 아키텍처에 의존하지 않는 c 코드가 다양한 시스템에서 올바르게 컴파일되고 실행되어야 하며, 아키텍처에 의존하는 코드는 커널 소스 트리에서 시스템 별 디렉터리에 적절히 분리되어 있어야 한다.