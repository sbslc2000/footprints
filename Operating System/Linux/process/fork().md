# fork()
리눅스는 fork()를 clone() 시스템 호출을 통해 구현한다. clone()은 부모와 자식이 어떤 자원을 공유하고, 어떤 자원은 복제할지에 대한 플래그를 받는다. 커널 쪽에서는 kernel/fork.c의 do_fork()와 copy_process()가 실질적인 처리를 수행한다.

do_fork()는 포크가 성공하면 자식을 깨워 실행시킨다. 일반적인 경우 자식은 곧바로 exec()을 호출하므로, 커널은 의도적으로 자식을 먼저 실행하도록 하여 부모가 먼저 주소 공간에 쓰기를 시작하면서 발생할 수 있는 [Copy-on-Write](Copy-on-Write.md) 오버헤드를 줄인다.

> [!info] ref count
> 프로세스의 메모리 디스크립터에는 두 가지 카운터가 있다.
> 1. mm_users : 이 주소 공간을 사용하는 프로세스 수
> 2. mm_count : 해당 mm_struct 자체의 참조 카운트 수
> fork()를 수행하면 mm_users가 2가 되고, 이를 통해 자식이 같은 메모리를 공유하므로 부모는 메모리를 수정할 시 Page fault가 발생하여 메모리를 복사한다. 한편 자식에서 exec()가 수행되고 나면 mm_users는 다시 1로 변하고, 이 경우 페이지 참조에 문제가 없어진다.