---
상위 개념: "[[Linux Process]]"
---
# Linux Process Termination
프로세스가 종료되면 커널은 해당 프로세스가 소유하던 자원을 해제하고, 부모에게 종료 사실을 알린다.

일반적으로 종료는 프로세스 자신이 `exit()` 시스템 콜을 호출하거나, `main()`이 반환된 후 컴파일러가 삽입한 `exit()` 호출에 의해 묵시적으로 종료된다. 물론 비자발적인 종료(예외 수신)도 가능하다. 종료 경로가 어떻게 되든, 핵심 작업은 `kernel/exit.c`의 `do_exit()`이 수행한다.

## do_exit()
`do_exit()`은 다음과 같은 일을 순서대로 처리한다.

1. task_struct의 플래그 중 PF_EXITING을 설정한다.

> [!info] PF_EXITING을 설정하는 이유
> 1. **종료 중임을 명시**: 커널 내부 코드가 이 프로세스를 정상 실행 상태로 오인하지 않도록 합니다.
> 2. **경합 방지**: 다른 커널 루틴이 해당 프로세스를 대상으로 접근·수정하려는 것을 차단합니다.
> 3. **정리 절차의 일관성 보장**: 메모리 해제, 파일 디스크립터 정리, 타이머 제거 등 후속 자원 정리 과정이 안전하게 수행되도록 합니다.

2. del_timer_sync()를 호출해 커널 타이머를 제거한다. 복귀 시점에는 큐에 타이머가 없고, 타이머 핸들러도 실행 중이 아님을 보장한다.

> [!info] 커널 타이머
> 커널 타이머는 일정 시간이 지난 뒤 커널이 실행할 함수를 예약해두는 메커니즘이다. 예를 들어 프로세스를 깨우거나 I/O 타임아웃을 처리할 때 사용된다.
> 
> del_timer_sync()는 특정 프로세스가 등록한 타이머 객체를 제거한다. 이렇게 하면 종료된 프로세스와 연결된 타이머 핸들러가 나중에 실행되어 이미 해제된 자원에 접근하는 문제를 방지할 수 있다.


3. BSD 방식의 프로세스 회계가 활성화되어있다면, acct_update_integrals()를 호출해 회계 정보를 기록한다.
4. exit_mm()을 호출해 프로세스가 보유한 mm_struct(주소 공간)을 해제한다. 주소 공간이 다른 프로세스와 공유되지 않았다면 파괴된다.
5. exit_sem()을 호출한다. IPC 세마포어를 기다리는 중이었다면 대기열에서 제거한다.
6. exit_files()와 exit_fs()를 차례로 호출하여 파일 디스크립터 및 파일시스템 관련 객체의 사용 카운트를 감소시킨다. 
7. task_struct의 exit_code에 종료코드를 저장한다. 이는 exit() 함수의 파라미터로 전달되었거나, 커널이 강제 종료 시 설정한 코드일 것이다.
8. exit_notify()를 호출하여 부모에게 시그널을 보내고, 이 태스크의 자식들을 같은 스레드 그룹의 다른 스레드 또는 init 프로세스로 reparenting한다.
9. task_struct의 exit_state를 EXIT_ZOMBIE로 바꾼다.
10. schedule()을 호출해 다른 프로세스로 전환한다.

10번을 수행하고 난다면, 이 태스크는 실행할 주소 공간도, 실행 가능한 상태도 아니므로 더 이상 스케쥴링의 대상이 안된다. 즉, do_exit()은 결코 반환되지 않는다.

EXIT_ZOMBIE 상태로 남아있는 태스크는 커널 스택, thread_info, task_struct만 남아있으며, 이 정보는 부모에게 제공된다. 부모가 정보를 수거하거나 관심 없음을 알리면, 남은 메모리도 해제되어 시스템에 반환된다.