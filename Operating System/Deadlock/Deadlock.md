---
상위 링크: "[[Operating System]]"
---
# Deadlock
> Deadlock can be defined as permanent blocking of a set of processes that either compete for system resources or communicate with each other

데드락이란 프로세스 집합에서 모든 프로세스가 다른 프로세스로부터의 인터럽트를 기대하며 기다리고 있는 상황을 의미한다.

## Deadlock Conditions
데드락은 다음과 같은 조건이 모두 **만족**될 때 발생할 **수** 있다.

1. 상호 배제*Mutual Exclusion* : 한 번에 하나의 프로세스만 자원을 사용할 수 있음.
2. 점유 대기*Hold and Wait* : 프로세스가 이미 할당된 자원을 점유한 채 추가 자원을 기다림
3. 선점 불가*No Preemption* : 할당된 자원을 강제로 빼앗을 수 없음.
4. 원형 대기*Circular Wait* : 여러 프로세스가 서로 다음 프로세스가 점유한 자원을 기다려 순환 대기 상태가 발생함.

## 어떻게 해결할까?

### Deadlock Prevention
Deadlock Prevention은 데드락이 발생하는 조건 중 적어도 하나를 만족하지 않게 하는 방법으로 데드락이 발생하지 않게 만드는 방법이다.
1. 상호배제를 막는 방법 : 애플리케이션 요구사항에 따라 대부분 포기할 수 없다.
2. 점유 대기를 막는 방법 : 어떠한 프로세스가 다른 리소스를 필요로 할 때, 어떠한 다른 리소스도 점유하지 않고 있다면 된다. 하지만 이 역시 대부분의 애플리케이션에서 적용할 수 없다.
3. 선점 방식 채택 : 자원을 뺏긴 쓰레드에서 에러 핸들링을 해야하고, 이것이 예측 불가능하게 발생할 것이고, 실패한 경우 재시도를 해야할지 어떻게 해야할지,, 참으로 곤란하다.
4. 원형 대기 만들지 않기 : 이것이 그나마 실용적인 방법이다.

원형 대기를 만들지 않기 위해서는 다음과 같은 방법을 사용할 수 있다.
1. 시스템 자원들에 번호를 부여한다.
	1. Ex. FILE:1, MEM:2, SSD:3,...
2. 리소스의 락을 획득할 때는, 항상 점유하고 있는 리소스보다 더 번호가 높은 것만 요청하자.
	1. 이 때 만약 해당 자원이 다른 프로세스에 의해 점유중이라면, 현 프로세스에서 점유중인 자원을 내려놓는다.

하지만 이는 Starvation의 문제를 발생시킨다.
### Deadlock Avoidance