---
상위 개념: "[[IPC]]"
---
# Message Passing
메시지를 통해 프로세스간에 데이터를 공유하는 기법이다.

Message Passing 모델에서는 데이터의 교환이 메시지를 통하여 이루어진다. Message Passing을 사용하면 프로세스는 직접 다른 공유 자원에 접근하지 않고도 통신을 할 수 있다. 운영체제는 프로세스 간 데이터를 전달할 수 있는 기능을 system call로 제공한다.

두 프로세스가 통신을 원한다면, 이들 사이에 communication link가 설정되어야 하며, 이것은 다양한 방법으로 구현할 수 있다. 이 링크를 구현하는 데에는 다음과 같은 고려사항들이 있다.
* 직접 & 간접 통신
* 동기식 & 비동기식 통신
* 자동 또는 명시적 버퍼링

## 직접 통신과 간접 통신
통신을 원하는 프로세스들은 서로를 가리킬 방법이 있어야 한다.

**직접 통신**에서는 통신에 필요한 api에 프로세스의 ID를 명시해야한다.
* send(P, message) : 프로세스 P로 메시지를 보낸다.
* receive(Q, message) : 프로세스 Q로부터 메시지를 받는다.

위와 같은 방법을 사용할 때에는 각각의 프로세스들이 통신의 대상이 되는 프로세스를 알고 있어야 하며, communication link는 정확히 P와 Q 사이에서만 발생한다. 

다음과 같이 변형해서 사용할 수도 있다.
* send(P, message) 
* receive(\*id , message) : 임의의 프로세스로부터 메시지를 수신하며, id는 메시지를 보낸 프로세스의 ID가 저장된다.
위 구조에서 메시지를 수신하는 측은 송신 측의 ID를 하드 코딩 할 필요가 없어서 조금 더 유연하게 사용할 수 있지만, 예상치 못한 메시지를 받을 가능성이 생긴다.

**간접 통신**에서 메시지는 메일박스 또는 포트를 통해 송\*수신 된다. 메일 박스란 메시지를 담고 있는 객체로 볼 수 있다. 
* send(A, message): 메시지를 메일박스 A로 보낸다.
* receive(A, message) : 메일박스 A로부터 데이터를 가져온다.

이 방법을 사용하면 communication link는 불특정 다수로부터 불특정 다수와 연결될 수 있다.

메일박스는 한 프로세스 또는 운영체제에 의해 소유될 수 있다. 프로세스에 의해 소유되는 메일박스의 수신자는 해당 프로세스로 한정된다. 운영체제에 의해 소유되는 메일박스는 기본적으로는 시스템 콜을 통해 해당 메일박스를 생성한 프로세스의 소유이지만, 이후 다른 시스템 콜을 통해 소유자를 추가할 수 있다.

## 동기적 통신과 비동기적 통신

메시지 전달은 blocking 과 nonblocking 방식으로 전달될 수 있다.
* **blocking send** : 송신하는 프로세스는 메시지가 수신될 때까지 기다린다.
* **non-blocking send** : 송신하는 프로세스는 메시지를 송신하고 본인의 작업을 수행한다.
* **blocking receivce** : 메시지를 받을때 까지 기다렸다가 작업을 수행한다.
* **non-blocking receive**: 메시지가 오지 않았다면 null을 받고 작업을 이어간다.

send와 receive가 모두 blocking일 때, 두 프로세스는 **rendezvous** 를 한다고 이야기한다.

## 버퍼링
메시지를 저장하는 저장공간 큐에 관련된 구현 고려사항들을 의미한다.
* **Zero Capacity** : 큐의 최대 길이가 0이므로, 송신자는 수신자가 메시지를 수신할 때까지 기다려야 한다.
* **Bounded Capacity** : 큐가 유한한 길이 n을 가져서, 송신자는 큐에 데이터를 넣고 수신자는 큐로부터 데이터를 받는 방식으로 동작한다. 공간이 유한하므로, 상황에 따라 송신자는 큐 안에 공간이 생길 때 까지 기다려야 할 수 있다.
* **Unbounded Capacity** : 큐는 무한한 길이를 가지게 설계되므로 송신자는 절대 기다릴 일이 없다.
