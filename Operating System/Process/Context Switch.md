---
상위 개념: "[[Process]]"
---
## Context Switch
일반적으로 컴퓨터는 여러가지 프로세스들이 수행되고 있습니다. 제가 줌을 켜놓고, 노션을 동시에 작성하는 것도 여러 프로세스가 수행되고 있기 때문입니다. 반면, 하나의 프로세서는 한 순간에 하나의 동작밖에 하지 못합니다. 프로세서는 오직 PC에 있는 메모리 주소에 있는 명령어를 가져오고(fetch) 수행하는(execution) 행동밖에 하지 못합니다. 즉, 서로 다른 프로세스는 동시에 수행될 수 없다는 것인데, 이 경우 줌과 노션이 동시에 실행되는 것은 불가능할 지도 모릅니다. 운영체제는 이러한 문제를 멀티프로그래밍(Multiprogramming)으로 해결합니다.

멀티프로그래밍이란 메모리에 여러 프로세스를 상주시키고 프로세서가 수시로 프로세스들을 전환하며 수행하여 마치 사용자가 여러 프로그램이 동시에 수행되는 것과 같은 환상을 주는 방법입니다. 프로세스들은 우리가 미처 알아차리지도 못할 정도로 빠르게 전환되며 프로세서로부터 수행되기 때문에 우리는 노션과 줌이 동시에 수행되는 것과 같은 느낌을 받을 수 있습니다. 이 때 프로세서가 수행하는 프로세스를 바꾸는 과정을 **문맥 교환**(Context Switch)라고 부릅니다.
![[Pasted image 20230921221122.png]]
Context Switch를 더 상세히 이해하기 위해 현재 메모리에 2개의 프로세스가 있는 상황을 가정합니다. 현재 CPU는 Process 0의 코드를 수행하고 있습니다. PC에 저장되어있는 명령어의 주소를 통해 명령어를 fetch 하고, 명령어를 수행할 것입니다. 이제 Process 0은 어느정도 수행했으니 동시성의 환상을 주기 위해 Process 1을 수행해야할 것입니다. CPU가 Process 1을 수행하게 만들어야 합니다.
이러한 전환은 여러 이유로 발생할 수 있습니다. 단순히 동시성을 위해 P0이 일정 시간 이상 수행되어서 전환을 하는 경우도 있고, P0이 I/O 요청을 하여서 그 응답을 기다리는 동안 CPU가 할 일이 없어져서 P1를 불러와야 하는 경우도 있을 수 있습니다.

여러 이유를 통해 P0이 전환되어야 하는 상황에서, 운영체제는 CPU의 제어를 뺏어온 뒤*interrupt or system call*, Context Switch를 수행합니다. Context Switch를 성공적으로 하기 위해서는 먼저 수행중이던 P0의 현재 상황을 P0의 PCB에 저장해야 합니다*save state into PCB0*. 어떤 명령어를 수행하다가 멈췄는지, 현재 어떤 함수를 수행하다가 멈췄는지에 대한 정보가 저장되어있어야 이후 다시 context switch를 통해 P0의 차례가 됐을 때 프로그램이 마저 동작할 수 있기 때문입니다. P0의 정보를 저장한 다음, CPU의 레지스터에는 PCB1 의 context 정보를 불러옵니다*reload state from PCB1*. 이를 통하여 CPU는 자연스럽게 P1을 수행할 수 있습니다.

P1이 모종에 이유로 전환되어야 한다면 같은 과정이 반복됩니다. 운영체제가 CPU를 점유한 뒤 CPU의 context 정보를 PCB1에 저장하고, PCB0의 정보를 다시 CPU에 옮김으로써 P0은 기존에 종료된 상태로 돌아가 수행을 이어갈 수 있습니다.

이렇게 발생하는 전환 시간은 dispatch latency라고 부르며, 사용자 프로세스가 수행되지 못하므로 순수한 오버헤드이다. 따라서 빈번한 context switch에 의한 오버헤드를 줄이기 위해서 하드웨어적 지원을 하기도 한다. 예를 들어 몇몇 시스템에서는 프로세서 레벨의 레지스터 집합을 여러개를 제공하여 모든 문맥 정보를 덮어 씌우는 것이 아닌 단순히 포인터를 이동하는 방식으로 전환하기도 한다. 이러한 전환 매커니즘은 운영체제의 메모리 관리 기법에 의존하므로 각각의 운영체제는 그들이 갖고 있는 메모리 시스템에 효율적인 매커니즘을 갖게 된다.