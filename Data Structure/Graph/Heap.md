---
공식 링크: "[[Tree]]"
---
# Heap
힙(Heap)이란 완전 이진 트리의 일종으로, 부모 노드와 자식 노드 간의 대소 관계를 유지하는 트리 구조이다. 우선 순위 큐(priority queue)를 구현하는 데 자주 사용된다.

무순서 선형 연결리스트를 사용할 때 우선 순위 큐 동작의 시간복잡도는 다음과 같다. N은 데이터의 개수이다.
* top(우선순위가 가장 높은 데이터 찾기) : $O(N)$
* isEmpty : $O(1)$
* pop(우선순위가 가장 높은 데이터 꺼내기): $O(N)$ 
* push: $O(1)$

한 편 힙 구조를 사용하면 다음과 같은 시간복잡도를 갖는다.
* top: $O(1)$
* isEmpty: $O(1)$
* pop: $\log N$
* push: $\log N$ 

## 정의
* Max(min) Tree: 각 노드의 키 값이 그 자식의 키 값보다 작지(크지) 않은 트리이다.
* **Max Heap** : Max Tree 이면서 완전 이진 트리
* **Min Heap** : Min Tree 이면서 완전 이진 트리


## 삽입과 삭제
삽입 시 원소의 정확한 위치를 결정하기 위해서는, 트리의 새 노드에서 시작해서 루트쪽으로 올라가는*bubbling up* 방법을 사용해야 한다.
![](https://i.imgur.com/Q95grVz.png)

완전 이진트리를 유지하기 위한 위치의 자리에 노드를 삽입한 뒤, 부모의 키와 비교하여 위치를 바꾸어 주는 것을 반복적으로 수행한다. 위 경우 최소 힙으로, 최초 삽입된 `(8,W)`는  제 위치를 찾아 더 이상의 이동을 하지 않았다. 한 편 두번째로 삽입된 `(2,T)`는 부모의 키보다 작기에 부모의 위치와 바꾸는 과정을 반복함으로써 힙 구조를 유지하였다. 위 과정은 최악의 경우 트리의 깊이에 비례하는 연산이 발생하므로 $\log_2N$의 시간복잡도를 갖는다.

삭제는 항상 루트노드에서만 발생하며, 루트 노드 데이터 삭제 이후 마지막 아이템을 루트로 옮긴 후, 해당 값이 제 위치를 찾아갈 수 있도록 삽입시의 로직과 위아래만 바뀐 유사한 로직을 수행해주면 된다.

## 구현
위 그림은 개념적인 그림으로, 실제 데이터 저장은 위와 같이 노드와 링크로 구현할 수도 있고, 선형 배열에서 구현할 수도 있다.