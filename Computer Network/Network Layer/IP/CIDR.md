---
상위 링크: "[[Internetworking Protocol]]"
---
# Classless Interdomain Routing
서브네팅에는 이를 보완하는 개념이 있는데, 이를 슈퍼네팅*Supernetting*이라고 부르기도 하지만, 더 일반적으로는 CIDR이라고 부릅니다. CIDR은 [서브네팅](Subnetting.md)의 아이디어를 논리적으로 확장하여 **주소 클래스를 완전히 제거**합니다. 그렇다면 왜 서브네팅만으로는 충분하지 않을까요? 본질적으로 서브네팅은 하나의 클래스 주소를 여러 서브넷으로 나누는 데 그치지만, **CIDR은 여러 클래스 주소를 하나의 “슈퍼넷”으로 결합할 수 있게 해줍니다.** 이는 주소 공간 비효율성을 더욱 효과적으로 해결하며, 동시에 라우팅 시스템의 과부하를 방지합니다.

주소 공간 효율성과 라우팅 시스템의 확장성 문제의 연관성을 이해하기 위해, 256개의 호스트를 가진 가상의 회사 네트워크를 예로 들어보겠습니다. 이 회사는 클래스 C 주소(최대 255개 호스트 지원)로는 부족하므로 클래스 B 주소를 할당받아야 한다고 가정해봅시다. 하지만, 클래스 B 주소는 65,535개의 호스트를 지원할 수 있는 주소 공간을 차지하는데, 이를 256개의 호스트를 위해 사용하는 것은 효율성이 단지 256/65,535 = 0.39%에 불과합니다. **서브네팅이 주소를 더 세밀하게 할당하는 데 도움을 줄 수는 있지만, 255개 이상의 호스트를 가지거나 그렇게 확장될 가능성이 있는 조직이 클래스 B 주소를 원한다는 사실은 바뀌지 않습니다.**

이 문제를 해결하는 첫 번째 방법은, 클래스 B 주소를 요청하는 조직에게 그들이 64,000개에 가까운 주소가 필요하다는 증거를 제공하지 못하면 할당을 거부하고, 대신 **클래스 C 주소를 필요한 만큼 제공**하는 것입니다. 이제 우리는 256개 주소 단위로 주소 공간을 할당하게 되므로, 조직의 크기에 맞게 소비되는 주소 공간을 더 정확하게 조정할 수 있습니다. 256개 이상의 호스트를 가진 조직의 경우, 최소한 50% 이상의 주소 활용률을 보장할 수 있으며, 일반적으로 그보다 훨씬 높은 효율성을 기대할 수 있습니다.

그러나 이 해결책에는 최소한 동일한 수준으로 심각한 문제가 하나 더 있습니다. 그것은 바로 **라우터의 과도한 저장 요구사항**입니다. 예를 들어, 단일 사이트에 16개의 클래스 C 네트워크 번호가 할당되었다고 가정해봅시다. 이 경우, 모든 인터넷 백본 라우터는 해당 사이트로 패킷을 전달하기 위해 **라우팅 테이블에 16개의 항목**을 유지해야 합니다. 이는 해당 네트워크들로 가는 경로가 모두 동일하더라도 마찬가지입니다.

만약 해당 사이트에 클래스 B 주소를 할당했다면, 동일한 라우팅 정보는 **하나의 테이블 항목**에 저장될 수 있었을 것입니다. 하지만 이 경우 주소 할당 효율성은 단지  6 * 255 / 65,536 = 6.2% 에 불과하게 됩니다.

따라서 CIDR(Classless Interdomain Routing)는 **라우터가 알아야 할 경로의 수를 최소화**하려는 **요구와 주소를 효율적으로 할당하려는 요구** 사이에서 균형을 맞추려고 합니다. 이를 위해 CIDR은 경로를 **집약***aggregation*할 수 있도록 도와줍니다. 즉, 포워딩 테이블의 단일 항목으로 여러 네트워크에 도달하는 방법을 알 수 있게 합니다. 이는 앞서 언급했듯 주소 클래스 간의 경계선을 깨뜨림으로써 이루어집니다.

이 원리를 이해하기 위해, 클래스 C 네트워크 번호 16개를 보유한 가상의 조직을 생각해봅시다. 16개의 주소를 무작위로 할당하는 대신, **연속적인 클래스 C 주소 블록**을 할당할 수 있습니다. 예를 들어, 192.4.16부터 192.4.31까지의 클래스 C 네트워크 번호를 할당한다고 가정해봅시다. 이 범위에 포함된 모든 주소의 상위 20비트는 동일합니다(11000000 00000100 0001). 이를 통해 **20비트 네트워크 번호**가 생성되며, 이는 호스트 지원 규모 측면에서 클래스 B 네트워크 번호와 클래스 C 번호의 중간 수준에 해당합니다.

즉, 우리는 클래스 B 네트워크보다 작은 주소 블록을 할당함으로써 높은 주소 효율성을 얻을 뿐만 아니라, 단일 네트워크 접두사를 포워딩 테이블에 사용할 수 있게 됩니다. 이 방식이 작동하려면, 공통된 접두사를 공유하는 연속적인 클래스 C 주소 블록을 할당해야 하며, 각 블록은 반드시 **2의 거듭제곱 수**의 클래스 C 네트워크를 포함해야 합니다.

CIDR은 네트워크 번호를 나타내기 위한 새로운 표기법을 필요로 합니다. 이는 접두사*prefix*로 알려져 있으며, 접두사는 길이가 임의일 수 있기 때문입니다. 관례적으로, 접두사 뒤에 /X를 붙여 표시하며, 여기서 X는 접두사의 비트 길이를 나타냅니다. 

앞선 예에서, 192.4.16부터 192.4.31까지의 모든 네트워크를 위한 20비트 접두사는 **192.4.16/20**으로 나타냅니다. 반면, 24비트 길이의 단일 클래스 C 네트워크 번호를 나타내려면 **192.4.16/24**로 표기합니다. 오늘날에는 CIDR이 표준이므로, 사람들이 클래스 C 네트워크보다는 “슬래시 24(/24)” 접두사에 대해 이야기하는 경우가 더 흔합니다.

이 방식으로 네트워크 주소를 표현하는 것은 서브네팅에서 사용되는 **(마스크, 값)** 접근법과 유사합니다. 다만, 마스크가 가장 중요한 비트(MSB)부터 연속된 비트로 구성된 경우(실제로는 거의 항상 그렇습니다)라는 조건이 붙습니다.

![](https://i.imgur.com/RqG0NVh.png)

방금 본 것처럼 네트워크 가장자리에서 경로를 집약할 수 있는 기능은 첫 단계에 불과합니다. 인터넷 서비스 제공자(ISP) 네트워크를 상상해 보십시오. ISP의 주요 역할은 다수의 기업과 캠퍼스(고객)에게 인터넷 연결을 제공하는 것입니다. 만약 고객 네트워크에 접두사를 할당할 때, 제공자 네트워크에 연결된 여러 고객 네트워크가 공통된, 더 짧은 주소 접두사를 공유하도록 할당한다면, 경로를 더욱 효과적으로 집약할 수 있습니다.

그림 9의 예를 고려해 봅시다. 제공자 네트워크에 의해 서비스되는 8개의 고객이 각각 인접한 24비트 네트워크 접두사를 할당받았다고 가정합시다. 이 접두사들은 모두 동일한 21비트로 시작합니다. 고객들이 모두 동일한 제공자 네트워크를 통해 도달 가능하므로, 제공자 네트워크는 이 고객들 모두를 위한 하나의 경로를 광고할 수 있습니다. 이를 위해 공유하는 공통 21비트 접두사만 광고하면 됩니다. 심지어 모든 24비트 접두사가 아직 할당되지 않았더라도, 제공자가 궁극적으로 이 접두사들을 고객에게 할당할 권리를 가지고 있는 한 가능합니다.

이를 달성하는 한 가지 방법은 주소 공간의 일부를 제공자에게 미리 할당하고, 네트워크 제공자가 해당 공간에서 고객의 필요에 따라 주소를 할당하도록 하는 것입니다. 이 간단한 예와는 달리, 모든 고객의 접두사가 동일한 길이를 가져야 할 필요는 없습니다.