---
상위 개념: "[[Reliable Transmission]]"
---
# Selective Repeat Protocol
![](https://i.imgur.com/whJRt16.png)

Go-Back-N 프로토콜은 신뢰성 있는 전송을 위한 프로토콜이다. GBN은 패킷 하나의 오류 때문에 여러 패킷을 재전송하게 되는 문제가 발생한다. SR은 이와 다르게 오류가 발생했거나 손실된 패킷만을 송신자가 재전송하는 프로토콜로, 불필요한 재전송을 줄여준다.

SR을 사용할 때 송신자는 전송했던 패킷 각각에 대하여 타임아웃을 유지해야한다. 또한 SR은 필연적으로 수신자가 SACK을 보내도록 요구한다. 또한 수신자는 out-of-order 패킷을 버퍼에 저장해야할 필요를 갖는다.

![](https://i.imgur.com/Pt3Ul8Z.png)

위 그림은 송신자와 수신자의 윈도우를 보여준다. 송신자의 윈도우에는 전송한 패킷중에 ACK을 받은 것과 받지 않은 것이 존재한다. send_base에 존재하는 패킷에 대해 ACK이 도착하면, 윈도우는 send-base가 그 다음 ACK을 받지 못한 패킷을 가리킬 때까지 이동한다.

수신자 측의 윈도우의 recv_base는 항상 받지 못한 패킷 번호 중 첫번째를 가리킨다. 해당 패킷 번호보다 큰 경우에도 패킷은 도착했을 수 있으며, 이는 버퍼에 저장된다. recv_base에 해당하는 패킷이 도착한다면 윈도우는 recv_base는 그 다음 받지 못한 패킷 번호를 가리킬 때 까지 이동하며, 해당 공간보다 앞(윈도우에서 막 벗어난)에 있는 패킷들은 애플리케이션 레이어에 전달된다.

## SR Dilema
![](https://i.imgur.com/MEXVxt0.png)

만약 윈도우 사이즈가 3개이고, 패킷 번호가 0부터 4까지 유지되는 경우, 문제가 발생할 수 있다.

첫번째 케이스는 수신자가 3개의 패킷을 받은 뒤 각각의 ACK을 보냈지만 모든 ACK이 전송 중 손실되었다. 송신자는 타임아웃 이후 수신자가 패킷을 못받았음을 간주하고 0번 패킷을 다시 전송한다.

두번째 케이스는 첫 세개의 패킷은 정상적으로 송수신되었고, pkt3은 손실, pkt0은 정상적으로 전송되었다. 

문제는 둘의 경우에 수신자 측에서 수행하는 동작은 똑같다는 것이다. 수신자는 다시 들어온 패킷이 재전송된 0번 패킷인지, 아니면 새로운 0번 패킷인지 알 방법이 없다.

이를 해결하기 위해 SR에서는 순서 번호의 비트 수를 $2^k >> 2n$ 를 만족하는 k의 값으로 설정할 필요가 있다. (n은 윈도우의 크기) 위 예시에서는 6보다 커야하는 $2^k$ 이므로 k는 최소 3이상, 즉 8개의 순서번호를 유지해야한다.