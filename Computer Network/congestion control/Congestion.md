---
상위 개념: "[[../Computer Network|Computer Network]]"
---
# Congestion
네트워크 혼잡(Congestion)이란 네트워크 내에 데이터 트래픽이 과도하게 몰려서, 라우터나 링크의 처리 용량을 초과하는 현상을 말한다. 이로 인해 패킷 지연(packet delay) 증가, 손실(packet loss) 발생, 처리율 감소 등의 문제가 발생한다.

아래 섹션에서는 혼잡의 원인과 비용을 알아보기 위해 몇몇 시나리오들을 분석해 볼 것이다.

## 패킷 도착률과 큐잉 지연
첫번째 시나리오는 호스트 A와 B가 단일 라우터를 통해 데이터를 전송하며, 라우터는 무한대의 버퍼 공간을 갖는다고 가정한다. A와 B는 각각 C와 D에 데이터를 전송한다.
![](https://i.imgur.com/pCMcd7o.png)
호스트 A의 애플리케이션에서 $\lambda_{in}/sec$ 의 속도로 데이터를 전송한다고 가정하자. 라우터의 출력 용량은 R로 가정한다. 호스트 B도 동일하게 동작한다. 수신자가 받은 데이터 양은 $\lambda_{out}$으로 정의한다.
![](https://i.imgur.com/99ooyir.png)
이 때 호스트 A에서의 처리량(좌측)과 지연(우측)은 위와 같다. 처리량은 R/2가 되는 시점까지는 전송하는 데이터가 늘어남에 따라 동일하게 늘어난다(호스트 B도 R/2만큼을 전송하기 때문). 이후에는 라우터의 출력 링크가 보내는 용량보다 입력의 용량이 많아지므로 병목이 발생하여, 처리량은 R/2로 유지된다.

지연의 경우 R/2에 가까워짐에 따라 무한대로 증가한다. 이유는 [[Queueing Delay]]에서 확인할 수 있다.

처리량이 R/2에 가까워지는 것은 링크를 최대한 활용하게 되므로 좋은 현상이다. 하지만 링크의 사용률이 높아짐에 따라 평균 지연 시간은 무제한에 가까워진다. **패킷 도착률이 링크 용량에 근접함에 따라 큐잉 지연은 커진다.**

## 재전송의 불필요한 링크 대역폭 사용
시나리오 1을 약간 변경해본다. 

![](https://i.imgur.com/zuiy3An.png)

* 라우터의 버퍼는 유한하다고 가정한다: 버퍼가 가득찼을 때 들어오는 패킷은 버려진다.
* 각 연결은 신뢰적이다: 패킷이 버려지면, 송신자는 재전송을 한다.
* 송신율을 새롭게 정의한다.
	* $\lambda_{in}/sec$ : 애플리케이션이 원래의 데이터를 소켓으로 보내는 송신율
	* $\lambda'_{in}/sec$ : 트랜스포트 계층에서 네트워크 계층을 통해 전송하는 송신율.
		*  $\lambda'_{in}/sec \geq \lambda_{in}$ 이다.
		* 이는 제공된 부하(offered load)라고도 부른다.

![](https://i.imgur.com/eGwvOgm.png)
만약 호스트가 라우터에 있는 버퍼가 비어있는지 그렇지 않은지를 알 수 있는 마법과 같은 상황이라면, $\lambda_{in}$은 $\lambda'_{in}$과 같으므로 어떠한 손실도 발생하지 않으며, 연결의 처리량은 $\lambda_{in}$과 같다. 이는 위 그림 a 에 나와있다.

호스트가 패킷이 확실히 손실된 것을 알았을 때만 송신자가 재전송하는 좀 더 현실적인 상황을 가정해보자. 이 때의 성능은 그림 b와 같다. 송신율이 R/2에 근접하지 않을 때는 라우터의 버퍼가 여유로우므로 보내는 데이터마다 송신에 성공한다. 하지만 링크 한계에 다다를수록 평균 지연 시간이 늘어나며, 일부 패킷은 버려질 수도 있다. 버려지는 패킷은 재전송될 것이며, 이는 결국 $\lambda_{out}$이 선형적으로 증가하지 않는 원인이 된다. 위 그림에서 R/2와 R/3 사이의 간격은 **버퍼 오버플로우로 인한 재전송에 의해 발생하는 손실**이다.

마지막으로, 송신자에서 너무 일찍 타임아웃 되어 패킷이 손실되지 않았지만 큐에서 지연되고 있는 패킷을 재전송하는 경우를 생각해보자. 이 때 중복된 패킷은 링크를 사용하지만, 수신자로부터 버려진다. 이 작업은 유의미한 패킷을 전송했어야 할 링크를 낭비하기에 분명한 낭비다. 혼잡 네트워크의 또 다른 비용은 **커다란 지연으로 인한 송신자의 불필요한 재전송**이다. 그림 c에서 이 현상을 볼 수 있다. 각 패킷이 평균적으로 두 번씩 전송된다고 할 때, 제공된 부하가 R/2인 경우 실질적으로 수신자가 받는 패킷은 R/4가 된다.

## 멀티 홉
![](https://i.imgur.com/kAwJ2dy.png)

마지막 시나리오에서 4개의 호스트는 위 그림과 같이 겹쳐지는 2홉 경로를 통해 패킷을 전송한다. 

호스트 A에서 호스트 C의 연결은 라우터 R1과 R2를 경유하며, 호스트 B와 호스트 D의 연결은 라우터 R2와 R3을 경유한다. 이들은 라우터 R2을 공유한다.

$\lambda_{in}$이 작다면 버퍼 오버플로우는 거의 발생하지 않고, 처리량은 제공된 부하와 거의 같다. 처리량은$\lambda_{in}$이 증가함에 따라 점차 커질 것이다.

$\lambda_{in}$이 매우 큰 경우를 살펴보자. 라우터 R2의 버퍼 공간은 A에서 C로 향하는 트래픽과 B에서 D로 향하는 트래픽이 경쟁하게 된다. 이들은 서로 독립적인 연결임에도 불구하고, R2의 출력 링크 대역폭을 공유하며 큐잉 지연이 증가한다. 이때 두 흐름이 동시에 전송률을 증가시키면, 결국 R2의 큐가 포화되어 패킷 드롭이 발생한다.

![](https://i.imgur.com/P4CUgUi.png)

패킷 손실은 재전송을 유발한다. 이 과정에서 새로운 데이터뿐 아니라, 이미 전송되었던 손실 패킷이 다시 네트워크에 삽입된다. 중요한 점은 이 재전송 패킷조차도 동일한 혼잡 경로를 반복해서 통과해야 한다는 것이다. 따라서 큐가 가득 찬 상태에서 재전송이 이루어질 경우, 정상적인 새로운 데이터보다 재전송 데이터가 우선적으로 큐를 채우게 되고, 결국 **유용한 유효 데이터 전송률이 급격히 저하**되는 현상이 발생한다.

이와 같은 상황이 심화되면 **네트워크는 전체적으로 매우 높은 전송률을 유지하고 있음에도 불구하고, 실제로 성공적으로 도착하는 유효 데이터는 거의 없는 상태**에 빠진다. 이 현상이 바로 혼잡 붕괴(Congestion Collapse)이다. 

여기서 혼잡 때문에 패킷을 버려야 하는 또 다른 비용을 알 수 있다. 
> 패킷이 경로상에서 버려질 때, 버려지는 지점까지 패킷을 전송하는 데 사용된 상위 라우터에서 사용된 전송 용량 역시 낭비된다.