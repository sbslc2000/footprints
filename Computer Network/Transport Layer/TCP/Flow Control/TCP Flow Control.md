---
상위 개념: "[[TCP]]"
---
# TCP Flow Control
TCP는 수신받은 세그먼트를 수신 버퍼에 저장하고, 애플리케이션은 필요에 따라 버퍼에서 데이터를 읽는다. 이 때 송신자가 세그먼트를 전송하는 속도보다 애플리케이션이 세그먼트를 읽는 속도가 느리다면, 수신 버퍼는 가득 차고 데이터는 오버플로우되어 버려질 수 있다. 

TCP는 이러한 문제를 해결하기 위해 흐름 제어 서비스(flow-control service)를 제공한다. TCP 헤더에 존재하는 16비트의 수신 윈도우(receive window)가 흐름 제어 서비스를 위한 공간으로 활용된다.

![](https://i.imgur.com/i4N9sRR.png)

수신자는 애플리케이션이 마지막으로 읽은 바이트 번호(LastByteRead)와 송신자로부터 마지막으로 받은 바이트 번호(LastByteRcvd)를 유지한다. LastByteRcvd - LastByteRead는 버퍼에 도착했으나 아직 애플리케이션으로부터 읽지 않은 바이트들이며, 이 값은 항상 수신 버퍼 사이즈(RcvBuffer)보다 작아야 오버플로가 발생하지 않는다.
```
rwnd = RcvBuffer - (LastByteRcvd - LastByteRead)
```

이 규칙에 따라 버퍼의 여유 공간을 계산할 수 있으며, 이 값을 수신 윈도(rwnd)라 명명한다. 이 값은 매 세그먼트 전송마다 rwnd 헤더에 담아서 전송된다. 이는 송신자에게 수신 버퍼에 얼마만큼의 여유공간이 있는지 알려주는 효과를 갖는다.

한 편, 송신자 측은 마지막으로 전송한 바이트 번호(LastByteSent)와 마지막으로 수신 응답을 받은 바이트 번호(LastByteAcked)를 유지해야한다. LastByteSend - LastByteAcked는 전송은 했으나 아직 수신이 확신하지 않은 바이트들로, 송신자는 이 값이 rwnd보다 낮게 유지함으로써 버퍼 오버플로가 발생하지 않게 만들 수 있다.

> [!info] 다음 수식은 항상 보장되어야 한다.
> LastByteSent - LastByteAcked $\leq$ rwnd

이 방법은 한가지 기술적 문제를 갖는다. 만약 수신자가 버퍼 여유공간이 없어 rwnd를 0으로 보냈다고 해보자. 송신자는 버퍼 오버플로를 막기 위해 송신을 잠시 멈춘다. 수신자 측 애플리케이션은 수신 버퍼의 데이터를 사용할 것이고 수신 버퍼는 여유공간이 생길 것이다. 허나 만약 이 때 수신자 측에서 보낼 세그먼트가 없어 최신의 rwnd 정보를 송신자에게 보내지 않는다면, 송신자는 여유 공간이 생겼다는 정보를 받지 못해 계속 기다리게 될 것이다.

이러한 문제를 해결하기 위해 TCP 명세서는 **송신자가 만약 수신자의 rwnd 값이 0이라면, 1바이트 데이터로 세그먼트를 계속 전송하도록 요구**한다. 수신자는 전송할 데이터가 없더라도 ACK을 보내면서 자연스레 최신의 rwnd 값을 보내게 된다.


