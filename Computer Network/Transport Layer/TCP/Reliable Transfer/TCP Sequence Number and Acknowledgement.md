---
"": "[[TCP Reliable Transmission]]"
---

# TCP Sequence Number and Acknoledgement
TCP는 신뢰적인 데이터 전송을 위해 순서 번호 필드와 확인응답 번호 필드를 매 전송마다 유지한다.

TCP는 데이터를 구조화되어 있지 않고 단지 순서대로 정렬되어 있는 바이트 스트림으로 본다. TCP의 순서 번호 사용은 순서 번호가 일련의 전송된 세그먼트에 대해서가 아니라, 전송된 바이트 스트림의 관점을 반영한다. 세그먼트에 담겨 있는 순서번호는 세그먼트에 있는 첫ㅎ 번째 바이트의 바이트 스트림 번호이다.
![](https://i.imgur.com/W3NSKXP.png)

호스트 A가 위 그림과 같이 하나의 파일을 전송할 때, 해당 파일의 데이터 스트림은 바이트 별로 암시적으로 순서번호가 부여된다. 만약 파일이 500,000바이트로 구성되어 있으며, MSS가 1,000 byte라고 할 때, 총 500개의 세그먼트가 구성된다. 이 때 첫번째 세그먼트의 순서 번호는 0일 것이며, 두번째 세그먼트의 순서 번호는 1,000이 된다. 

확인응답 번호는 다음과 같이 구성된다. '호스트 A가 자신의 세그먼트에 삽입하는 확인응답 번호는 호스트 A가 호스트 B로부터 기대하는 다음 바이트 순서다'. 즉, 만약 위 그림에서 A가 첫번째 세그먼트를 전송하면, 호스트 B는 데이터를 잘 받았다는 의미로 확인응답 번호에 1,001을 담아서 전송한다. 이 때 호스트 B가 확인응답 번호와 동시에 자신이 보내려는 데이터의 순서번호, 그리고 데이터 필드에 해당 바이트 스트림을 담아 보낼 수 있다는 점에 유의하자! TCP는 duplex를 지원한다.
![](https://i.imgur.com/PGLzQr5.png)

## Cumulative ACK
만약 호스트 A가 0부터 500까지의 바이트 번호를 가진 데이터를 받은 이후, 900에서 100까지의 바이트 번호를 가진 데이터를 수신하면 어떻게 해야할까? TCP는 이에 대해 누적 확인응답(Cumulative ACK, CACK)을 보낸다. 호스트 A는 501을 확인응답 번호로 담고 있는 패킷을 보내며, 송신자는 이를 통해 데이터 전송에 실패했음을 알 수 있다.

이 때 수신자가 out-of-order 바이트 스트림을 저장해두어야 한다는 법은 없다. 이는 TCP RFC에 명시되어있지 않으므로, TCP를 구현하는 측에서 결정하면 된다.

## Initial Sequence Number
위 그림에서는 순서번호가 0부터 시작된다고 가정했지만, 사실은 그렇지 않다. 실제로는 TCP 연결 과정에서 시작 순서 번호를 임의로 선택하고, 이를 양 측간에 공유한다. 이는 네트워크에 남아 있던 세그먼트가 두 호스트 간의 나중 연결에서 유효한 세그먼트로 오인될 확률을 최소화하는 효과를 갖는다.