---
상위 개념: "[[TCP]]"
---
# TCP Connection
TCP 연결 설정 절차는 3개의 특수한 패킷을 송신하는 방식으로 동작하며, 이러한 이유로 **세 방향 핸드셰이크**(three-way handshake)라고도 부른다.

![](https://i.imgur.com/akrfEaC.png)
1단계 : 연결을 수립하기를 원하는 클라이언트는 SYN 패킷을 보낸다. SYN 패킷은 헤더의 SYN 비트에 1이 담겨있으며, 최초의 순서번호를 임의로 생성하여 순서번호 필드에 넣는다. 이 패킷은 애플리케이션 계층 데이터를 포함하지 않는다.

2단계 : SYN 패킷이 서버에 도착하면, 서버는 버퍼 공간과 변수를 할당한다. 이후 SYNACK 패킷을 클라이언트에게 전송한다. SYNACK 패킷은 SYN 비트에 1이 담겨있으며, 서버에서 사용할 최초 순서번호를 담고 있고, ACK 필드에는 클라이언트의 패킷을 잘 받았다는 의미로 클라이언트의 순서번호 + 1 값을 담아 전송한다. 애플리케이션 계층 데이터는 포함되지 않는다. 이는 다음과 같은 의미를 갖는다.

> 나는 당신의 최초 순서 번호인 client_isn을 가지고 연결을 시작하자는 당신의 SYN 패킷을 수신했다. 나는 이 연결 설정에 동의한다. 나 자신의 최초의 순서 번호는 server_isn이다

3단계 : 클라이언트가 SYNACK 패킷을 수신한다면, 클라이언트는 버퍼와 변수를 할당한다. 이후 클라이언트는 SYNACK을 잘 받았음을 확인하는 의미의 세그먼트를 송신한다. 이 패킷은 SYN이 0으로 설정되고, 확인응답 필드에는 서버의 순서번호 + 1의 값이 담겨있으며, 애플리케이션의 데이터를 페이로드로 운반할 수 있다.

일단 위 세 단계가 완료되면, 클라이언트와 서버 호스트들은 각각 서로에게 데이터를 포함하는 세그먼트를 보낼 수 있다.

## Connection Closing
![](https://i.imgur.com/z68j1br.png)

TCP에 연결에 참여하는 두 프로세스 중 하나는 연결을 끝낼 수 있다. 연결이 끝날 때 호스트의 '자원'(버퍼와 변수)는 회수된다.

위 그림 처럼 클라이언트가 연결 종료를 결정한다고 가정하자. 클라이언트의 TCP는 서버 프로세스에게 FIN 비트가 1로 설정된 세그먼트를 송신한다. 서버가 이 세그먼트를 수신하면, 서버는 클라이언트에게 확인응답 세그먼트를 보낸다. 그 다음에 FIN 비트가 1로 설정된 자신의 종료 세그먼트를 송신하며, 마지막으로 클라이언트는 서버의 종료 세그먼트에 확인응답을 한다.

위 예시는 클라이언트가 연결 종료를 결정했지만, 실제로는 두 호스트 중 어느쪽에서든 먼저 연결 종료를 시도할 수 있다.

위에서 Timed wait은 왜 존재할까? 클라이언트는 상대방의 종료 패킷을 받고 ACK을 보내고 나서도 약간의 시간을 기다린다. 이는 마지막으로 전송한 ACK이 손실되었을 때 해당 ACK을 재송신하기 위함이다. TIME_WAIT의 시간은 구현에 따라 다르지만, 일반적으로 30초, 1분 또는 2분이다. 대기시간이 끝난다면 연결은 정식으로 종료되고, 클라이언트 측의 모든 자원이 해제된다.

## 왜 3-way handshake이어야 하나?
만약 2-Way Handshake만 존재한다면, 서버는 클라이언트의 첫 SYN 세그먼트를 받고 SYN-ACK를 보낸 후 즉시 연결이 수립된 것으로 간주할 것이다. 하지만 만약 클라이언트의 첫 SYN 세그먼트가 사실은 네트워크에 지연되어 남아있던 오래된(duplicate) 세그먼트였다면, 서버는 유효하지 않은 요청에 대해 연결 상태를 할당하고 데이터를 보낼 준비를 할 수 있다.

세 번째 ACK 단계(클라이언트가 서버의 SYN-ACK에 대해 ACK를 보내는 단계)는 클라이언트가 서버의 ISN(SYN-ACK에 포함된)을 정상적으로 수신했음을 서버에게 확인시켜 준다. 이를 통해 서버는 자신이 보낸 SYN-ACK가 클라이언트에 의해 제대로 처리되었고, 클라이언트가 현재 이 새로운 연결에 대해 "살아있고(live)" 준비가 되었음을 확신할 수 있다. 이 최종 확인이 없다면, 서버는 연결이 실제로 수립되었는지 알 수 없다.

또한 이는 [SYN Flood Attack](SYN%20Flood%20Attack.md)을 방지하는 효과도 갖는다.
