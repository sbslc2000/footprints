---
상위 개념: "[[TCP]]"
---
# TCP Congestion Control
TCP는 혼잡한 네트워크 상황에서는 전송 속도를 줄이고, 혼잡하지 않다면 전송 속도를 늘리는 매커니즘을 가지고 있다. 이러한 서비스는 IP 레이어에서 제공되지 않기 때문에, **종단 간의 혼잡 제어 서비스**라고 불린다.

## 기본 원리

### 어떻게 네트워크 혼잡을 감지하는가?
TCP는 전송 계층 프로토콜로, 그 아래 계층인 IP는 패킷 손실이나 지연에 대한 명시적인 피드백을 제공하지 않는다. 따라서 TCP는 스스로 네트워크의 혼잡 상태를 유추해야 한다.

* **RTT(Round-Trip Time)의 증가**는 중간 라우터의 큐에 패킷이 쌓이고 있다는 신호이며, 이는 네트워크가 혼잡해지고 있음을 나타낸다.
* **패킷 손실이 발생**하는 경우 라우터에서 패킷이 버려지는 경우이므로 네트워크가 혼잡하다는 것을 의미한다.

TCP는 직간접적으로 위 요소를 모두 사용하여 혼잡 제어를 수행한다. 또한, 패킷 손실에 대해서는 더 상세한 케이스 별로 혼잡 제어를 수행한다.

* Timeout이 발생하는 경우
* 3개의 중복된 ACK이 발생하는 경우

전송한 여러 세그먼트들이 모두 손실되는 경우, Timeout이 발생한다. 이는 네트워크가 매우 혼잡함을 의미한다. 이런 상황에서는 적극적으로 전송 속도를 줄일 필요가 있다.

3개의 중복된 ACK은 세그먼트들 중 하나의 패킷이 손실된 경우이다. TCP는 [Cumulative ACK](../../../reliable%20transmission/Cumulative%20ACK.md)을 사용하므로, 전송 세그먼트 \[A, B, C, D, E, F]에서 D가 손실되는 경우 송신자가 받게되는 ACK은 \[B, C, D, D, D, D]가 된다. 이렇게 3개의 중복 ACK이 발생하는 경우는 Timeout보다는 네트워크 혼잡도가 적다는 것을 시사하므로, 비교적 소극적으로 전송 속도를 줄일 필요가 있다.

### 어떻게 전송 속도를 조절하는가?
TCP에는 전송 속도 조절을 위한 cwnd 헤더를 유지한다. cwnd는 Congestion Window의 약자로, ACK을 받지 않은 상태에서 최대로 보낼 수 있는 바이트의 수(윈도우 사이즈) 값을 갖는다. cwnd의 크기가 자연스레 전송 속도를 결정한다.

ACK은 cwnd를 변경하는 트리거로 사용된다. ACK이 도착했다는 것은 네트워크가 혼잡하지 않다는 증거이므로, 링크의 가용률을 높이기 위해 cwnd를 증가시킨다. ACK이 도착하는 속도는 RTT와 관련이 있고, RTT는 큐잉 딜레이의 영향을 받는다. 큐잉 딜레이가 작은 상황은 네트워크가 혼잡하지 않은 상황이고, 더 작은 RTT를 갖기에, 더 자주 ACK을 받게되고, 따라서 cwnd는 빠르게 늘어난다. 한편 큐잉 딜레이가 긴 상황은 네트워크가 혼잡하다는 것을 의미하며, 더 긴 RTT를 갖게 되고, 따라서 덜 자주 ACK을 받게되므로 cwnd는 느리게 증가한다. 이렇게 ACK을 cwnd의 트리거로 사용하는 방식을 **자체 클로킹**(self-clocking)이라고 한다.

더 자세한 매커니즘은 아래 TCP Congestion Control과 TCP의 혼잡 제어 상태들을 알아봄으로써 이해할 수 있다.

## TCP Congestion Control States
### Slow Start
TCP 연결이 수립되고 나면 TCPsms 슬로우 스타트(Slow Start) 상태에 돌입한다.

![](https://i.imgur.com/ZRXUPtW.png)

슬로우 스타트는 cwnd의 초기값으로 1 MSS(Maximum Segment Size)로 설정하여, 하나의 ACK이 도착할 때마다 cwnd를 1 MSS 씩 증가시키는 상태이다.

전송하고자 하는 데이터가 충분히 크다고 가정해보자. 최초의 cwnd는 1이고, 하나의 세그먼트를 전송한다. 이후 RTT의 시간이 지나고 나면, ACK이 도착할 것이고 cwnd는 2로 증가되어 2개의 세그먼트를 전송할 수 있다. 그 다음 RTT에는 2개의 ACK이 도착할 것이므로 cwnd는 4가 될 것이다. 슬로우 스타트에서는 RTT마다 윈도우 사이즈가 2배가 되어 지수적으로 증가한다.

전송률을 지수적으로 증가시키다 보면 네트워크 혼잡이 발생할 수 있다. 위에서 살펴봤듯이, 네트워크 혼잡의 증거는 점점 증가되는 RTT와 패킷 손실이다. RTT에 따라서 전송 증가 속도는 점차 줄어들겠지만, 윈도우 사이즈를 줄이지는 않는다. 윈도우 사이즈를 줄이는 행동은 패킷 손실로부터 수행된다.

만약 타임아웃이 발생하면, ssthresh(슬로우 스타트 임계값)을 타임아웃이 발생한 cwnd의 절반 값으로 설정한 뒤, 새롭게 슬로우 스타트 모드로 들어간다. cwnd는 1 MSS로 설정되고, 지수적으로 증가할 것이다. 그러나 이 때에도 무작정 두 배씩 윈도우 사이즈를 증가시킨다면 다시금 네트워크의 혼잡이 발생할 것이다. 따라서 윈도우 사이즈가 sshthresh에 다다른다면, 슬로우 스타트 상태를 종료하고 혼잡 회피(Congestion Avoidance) 상태로 돌입한다.

타임아웃이 아닌 3개의 중복 ACK이 발생한 상황은 Timeout보다는 네트워크가 덜 혼잡한 상황이다. 따라서 이 경우 타임아웃과 같이 cwnd를 다시 1로 줄이는 극단적인 속도 조절을 하지 않고, cwnd를 문제가 발생한 cwnd의 절반으로 설정한 뒤 혼잡 회피 모드로 돌입한다.

### Congestion Avoidance
혼잡 회피 상태로 들어가는 시점에서 cwnd는 마지막으로 혼잡이 발생한 시점에서의 윈도우 사이즈의 절반일 것이다. 이 시점부터 TCP는 전송속도를 보수적으로 증가시킨다. 슬로우 스타트에서 하나의 ACK이 도착할 때 cwnd를 1 MSS만큼 증가시킨 것에 반하여, 혼잡 회피 상태에서는 ACK 도착시 cwnd를 MSS/cwnd 만큼 증가시킨다. 이는 RTT마다 1 MSS를 올리는 효과를 보인다.

혼잡 회피 상태에서도 패킷 손실은 발생할 수 있다. 만약 타임아웃이 발생한다면, 해당 cwnd의 절반을 ssthresh로 설정한 뒤, 슬로우 스타트 모드로 들어간다. 만약 3개의 중복 ACK이 발생한다면, sshthresh를 cwnd의 절반으로 설정한 뒤, 해당 지점부터 혼잡 회피 상태를 반복한다.


## AIMD
![a8XvzHe.png](https://i.imgur.com/a8XvzHe.png)
TCP 연결이 지속적으로 데이터를 보내고 있다고 해보자. 초기 슬로우 스타트는 무시하고, 타임아웃이 발생하지 않았다고 해보자. 이 때 시간에 따른 cwnd의 변동은 위 그래프의 모습과 같다. 위 그래프는 RTT마다 1 MSS씩 선형적으로 증가하는 부분과, 손실에 의해서 cwnd이 절반으로 줄어드는 부분으로 구성된다. 이러한 특징으로 인해 TCP의 혼잡제어는 AIMD(additive-increase, multiplicative decrease) 방식이라고 불린다.

## TCP CUBIC
네트워크 혼잡을 이유로 패킷 손실이 발생한 윈도우 크기를 $W_{max}$라고 하자. 네트워크 상황에 변동이 없다면, 윈도우 사이즈가 $W_{max}$ 에 근접하지 않는다면 패킷 손실이 발생하지 않을 것이고 네트워크 혼잡의 문제가 발생하지 않을 것이라 예측할 수 있다.

TCP 리노의 문제는 패킷 손실 이후 cwnd가 선형적으로 증가하면서 $W_{max}$ 의 근처까지 도달하는데에 너무 오랜 기간이 걸린다는 것이다. 이는 대역폭을 비효율적으로 사용하는 것일지도 모른다. 이러한 문제를 해결하기 위해 TCP 큐빅은 전송 속도를 빠르게 높여 실패 지점에 근접한 이후 다음 대역폭을 신중하게 조사하는 방법을 사용한다.

![](https://i.imgur.com/zyWwKtQ.png)

TCP 큐빅은 리눅스 운영체제에서 사용되는 TCP의 기본 버전이기도 하다.



