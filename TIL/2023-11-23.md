# 오늘 목표
1. ~~알고리즘 1문제 풀기~~
2. 스프링 데이터 JPA 강의 듣기 - Spring Data Common 전부 듣기
3. 김킹갓 스프링부트 강의 듣기 시작 - 섹션1, 섹션 2 절반

# 1일1PS
 * 문제 이름 : 임스와 함께하는 미니게임
 * 링크 : https://www.acmicpc.net/problem/25757
 * 풀이 : [1123 · sbslc2000/MyPsChallenge@bbc5fd0 · GitHub](https://github.com/sbslc2000/MyPsChallenge/commit/bbc5fd01596be6559b0f20b5bfbbf0ec777f1a52)
 * 알고리즘 분류 : 
 * 작성 일시 : 2023-11-23

중복 요소를 제거하는 방법들에 대해 궁금해졌다.

# 중복 요소 제거법
크게 정렬을 통한 방식과 해시를 사용한 방식이 있는 것 같다.
1. **정렬을 통한 중복 요소 제거**
정렬이 되어있다면 효율적이지만 정렬이 되어있다면 정렬에 필요한 시간이 추가로 발생한다. 정렬이 되어있다면 데이터를 한번만 스캔하여 중복 요소를 제거할 수 있으므로 $O(N)$ 이 소요될 것이며, 정렬이 되어있지 않다면 정렬에 필요한 시간에 의해서 $O(N \log N)$의 시간이 걸릴 것이다.

2. **해시를 통한 중복 요소 제거**
해시 테이블을 만들고 각 요소의 해시값을 통해 중복된 요소를 제거하는 방법이다. 모든 구분되는 데이터 요소가 구분되는 해시값을 가질 것이 보장되지 않는 경우 해시 테이블에 접근하여 값을 추가로 비교하고 체이닝을 통해 데이터를 저장하는 로직이 추가되어야 할 것 같다. 해시를 사용한다면 시간복잡도는 O(N)이 소요된다.

3. 공간 복잡도 측면에서는...
공간복잡도의 측면에서도 In-place와 Not-in-place 방식을 고려할 수 있을 것 같다. **In-place**의 경우 중복된 요소를 제거한 뒤 빈 배열 요소를 압축하는 로직이 들어가야 해서 계산량이 늘어나지만, 이는 배열을 한 번 순회하여 가능한 로직이므로 전체 시간복잡도에 주요한 영향을 주지는 않는다. 반면 **Not-In-place**의 경우 중복이 제거된 개수만큼의 추가적인 공간을 필요로 한다.

# Spring Data JPA

## Spring Data Common의 기본 구현체를 확장하는 방법 , 기본 레포지토리 커스터 마이징

모든 레포지토리에 공통적으로 적용시키고 싶은 기능이 있다면 어떻게 해야할까?

1. JpaRepository를 상속받는 인터페이스를 정의한다. 
이곳에 공통적으로 추가하고자 할 행동 목록을 작성한다. 이 인터페이스는 빈으로 등록되지 않아야 하므로 @NoRepositoryBean을 작성해주어야 한다.
```java
@NoRepositoryBean  
public interface MyRepository<T, ID extends Serializable> extends JpaRepository<T, ID> {  
  
    boolean contains(T Entity);  
}
```

2. 직접 만든 인터페이스를 구현하는 클래스를 작성한다.
JpaRepository의 기본 구현체인 SimpleJpaRepository를 상속하여 기능을 받아와야하며, 새로운 공통기능을 담고 있는 MyRepository를 implement하여 수행될 내용을 작성해준다.
```java
public class MyRepositoryImpl<T, ID extends Serializable> extends SimpleJpaRepository<T, ID> implements MyRepository<T, ID> {  
  
    private EntityManager entityManager;  
    
    public MyRepositoryImpl(JpaEntityInformation<T, ?> entityInformation, EntityManager entityManager) {  
        super(entityInformation, entityManager);  
        this.entityManager = entityManager;  
    }  
  
    @Override  
    public boolean contains(T entity) {  
        return entityManager.contains(entity);  
    }  
}
```

3.  @EnableJpaRepository에 구현체의 클래스를 등록해준다.
repositoryBaseClass 속성은 repository proxy를 설정하기 위한 기반 클래스를 지정해주며, 기본적으로는 아무런 추가적인 구현사항이 없는 DefaultRepositoryBaseClass로 설정이 되어있다. 
```java
@SpringBootApplication  
@EnableJpaRepositories(repositoryBaseClass = MyRepositoryImpl.class)  
public class Datajpa2Application {  
  
    public static void main(String[] args) {  
        SpringApplication.run(Datajpa2Application.class, args);  
    }  
  
}
```

```java
public final class DefaultRepositoryBaseClass {  
  
    private DefaultRepositoryBaseClass() {}  
}
```

4. 사용하고자 하는 레포지토리의 인터페이스를 변경한다.
```java
public interface PostRepository extends MyRepository<Post,Long> {  
}
```

이후 MyRepository를 상속한 모든 레포지토리 빈은 직접 구현한 메서드를 사용할 수 있게 된다.

# 스프링 데이터 Common:  도메인 이벤트

도메인 이벤트 퍼블리싱이란 도메인 객체의 변화를 이벤트로 만들고, 이벤트 리스너 측에서 도메인 객체의 변화를 감지하여 특정 코드를 실행하도록 만드는 기술이다.

## 이벤트 자동 퍼블리싱

스프링 데이터 Common은 save() 기능을 사용할 때 엔티티에 쌓여있던 이벤트를  자동으로 publishing하는 기능을 제공한다.

1. @DomainEvents
엔티티 이벤트를 모아두는 역할을 한다.
2.  @AfterDomainEventPublication
이벤트 컬렉션에 담겨있는 이벤트들을 발행한 뒤 이벤트 컬렉션을 비워주는 기능을 한다.

이것들은 직접 구현할 필요 없이 미리 구현되어있는 AbstractAggregationRoot\<E> 를 사용할 수 있다.

```java
public class AbstractAggregateRoot<A extends AbstractAggregateRoot<A>> {  
  
    private transient final @Transient List<Object> domainEvents = new ArrayList<>();  

	protected <T> T registerEvent(T event) {  
  
	    Assert.notNull(event, "Domain event must not be null");  
	  
	    this.domainEvents.add(event);  
	    return event;  
	}
  
	@AfterDomainEventPublication  
    protected void clearDomainEvents() {  
       this.domainEvents.clear();  
    }  
    
	@DomainEvents  
    protected Collection<Object> domainEvents() {  
       return Collections.unmodifiableList(domainEvents);  
    }
```

## 예제 
### 이벤트 정의
이는 POJO 로도 만들 수 있고, ApplicationEvent라는 스프링이 제공하는 클래스를 상속하여 만들수도 있다.
```java
public class PostPublishedEvent extends ApplicationEvent {  
  
    private final Post post;  
    public PostPublishedEvent(Object source) {  
        super(source);  
        this.post = (Post) source;  
    }  
  
    public Post getPost() {  
        return post;  
    }  
}
```

### 이벤트 리스너 생성

1. ApplicationListener를 활용하는 방법
```java
public class PostListener implements ApplicationListener<PostPublishedEvent> {  
	@Override  
	public void onApplicationEvent(PostPublishedEvent event) {  
		System.out.println("------------------");  
		System.out.println(event.getPost().getTitle() + " is published!!");  
		System.out.println("------------------");  
	}  
}
```
2. @EventListener를 사용하는 방법
```java
public class SimplePostListener {  
	@EventListener  
	public void onApplicationEvent(PostPublishedEvent event) {  
		System.out.println("------------------SimplePostListener");  
		System.out.println(event.getPost().getTitle() + " is published!!");  
		System.out.println("------------------");  
	}  
}
```

두 방법 모두 유효한 방법이고 모든 리스너들은 빈으로 등록되어야 한다.

### 도메인 클래스 수정
AbstractAggregationRoot의 registerEvent를 통해 발행하고자 하는 이벤트들을 생성한다.

AbstractAggregationRoot의 기능은 모두 protected로 작성되어있어서 외부에서 엔티티를 사용할 때 노출되지 않는다. 또한 이벤트 객체를 저장하는 컬렉션은 @Transient 애노테이션이 사용되어 매핑의 대상에서 제외된다.

```java
public class Post extends AbstractAggregateRoot<Post>{  
	...
  
    public Post publish() {  
        this.registerEvent(new PostPublishedEvent(this));  
        return this;  
    }  
}
```


이 작업을 거치면 postRepository.save()가 수행될 때 엔티티에 저장되어있던 이벤트 객체가 모두 발행된 후 지워진다. 이를 통해 행복 이벤트기반 프로그래밍을 할 수 있다.!