# 오늘 목표
1. ~~알고리즘 1문제 풀기~~
2. 스프링 데이터 JPA 강의 듣기 - Spring Data Common 전부 듣기
3. 김킹갓 스프링부트 강의 듣기 시작 - 섹션1, 섹션 2 절반

# 1일1PS
 * 문제 이름 : 임스와 함께하는 미니게임
 * 링크 : https://www.acmicpc.net/problem/25757
 * 풀이 : [1123 · sbslc2000/MyPsChallenge@bbc5fd0 · GitHub](https://github.com/sbslc2000/MyPsChallenge/commit/bbc5fd01596be6559b0f20b5bfbbf0ec777f1a52)
 * 알고리즘 분류 : 
 * 작성 일시 : 2023-11-23

중복 요소를 제거하는 방법들에 대해 궁금해졌다.

# 중복 요소 제거법
크게 정렬을 통한 방식과 해시를 사용한 방식이 있는 것 같다.
1. **정렬을 통한 중복 요소 제거**
정렬이 되어있다면 효율적이지만 정렬이 되어있다면 정렬에 필요한 시간이 추가로 발생한다. 정렬이 되어있다면 데이터를 한번만 스캔하여 중복 요소를 제거할 수 있으므로 $O(N)$ 이 소요될 것이며, 정렬이 되어있지 않다면 정렬에 필요한 시간에 의해서 $O(N \log N)$의 시간이 걸릴 것이다.

2. **해시를 통한 중복 요소 제거**
해시 테이블을 만들고 각 요소의 해시값을 통해 중복된 요소를 제거하는 방법이다. 모든 구분되는 데이터 요소가 구분되는 해시값을 가질 것이 보장되지 않는 경우 해시 테이블에 접근하여 값을 추가로 비교하고 체이닝을 통해 데이터를 저장하는 로직이 추가되어야 할 것 같다. 해시를 사용한다면 시간복잡도는 O(N)이 소요된다.

3. 공간 복잡도 측면에서는...
공간복잡도의 측면에서도 In-place와 Not-in-place 방식을 고려할 수 있을 것 같다. **In-place**의 경우 중복된 요소를 제거한 뒤 빈 배열 요소를 압축하는 로직이 들어가야 해서 계산량이 늘어나지만, 이는 배열을 한 번 순회하여 가능한 로직이므로 전체 시간복잡도에 주요한 영향을 주지는 않는다. 반면 **Not-In-place**의 경우 중복이 제거된 개수만큼의 추가적인 공간을 필요로 한다.

# Spring Data JPA

## Spring Data Common의 기본 구현체를 확장하는 방법 , 기본 레포지토리 커스터 마이징

모든 레포지토리에 공통적으로 적용시키고 싶은 기능이 있다면 어떻게 해야할까?

1. JpaRepository를 상속받는 인터페이스를 정의한다. 
이곳에 공통적으로 추가하고자 할 행동 목록을 작성한다. 이 인터페이스는 빈으로 등록되지 않아야 하므로 @NoRepositoryBean을 작성해주어야 한다.
```java
@NoRepositoryBean  
public interface MyRepository<T, ID extends Serializable> extends JpaRepository<T, ID> {  
  
    boolean contains(T Entity);  
}
```

2. 직접 만든 인터페이스를 구현하는 클래스를 작성한다.
JpaRepository의 기본 구현체인 SimpleJpaRepository를 상속하여 기능을 받아와야하며, 새로운 공통기능을 담고 있는 MyRepository를 implement하여 수행될 내용을 작성해준다.
```java
public class MyRepositoryImpl<T, ID extends Serializable> extends SimpleJpaRepository<T, ID> implements MyRepository<T, ID> {  
  
    private EntityManager entityManager;  
    
    public MyRepositoryImpl(JpaEntityInformation<T, ?> entityInformation, EntityManager entityManager) {  
        super(entityInformation, entityManager);  
        this.entityManager = entityManager;  
    }  
  
    @Override  
    public boolean contains(T entity) {  
        return entityManager.contains(entity);  
    }  
}
```

3.  @EnableJpaRepository에 구현체의 클래스를 등록해준다.
repositoryBaseClass 속성은 repository proxy를 설정하기 위한 기반 클래스를 지정해주며, 기본적으로는 아무런 추가적인 구현사항이 없는 DefaultRepositoryBaseClass로 설정이 되어있다. 
```java
@SpringBootApplication  
@EnableJpaRepositories(repositoryBaseClass = MyRepositoryImpl.class)  
public class Datajpa2Application {  
  
    public static void main(String[] args) {  
        SpringApplication.run(Datajpa2Application.class, args);  
    }  
  
}
```

```java
public final class DefaultRepositoryBaseClass {  
  
    private DefaultRepositoryBaseClass() {}  
}
```

4. 사용하고자 하는 레포지토리의 인터페이스를 변경한다.
```java
public interface PostRepository extends MyRepository<Post,Long> {  
}
```

이후 MyRepository를 상속한 모든 레포지토리 빈은 직접 구현한 메서드를 사용할 수 있게 된다.

# 스프링 데이터 Common:  도메인 이벤트

도메인 이벤트 퍼블리싱이란 도메인 객체의 변화를 이벤트로 만들고, 이벤트 리스너 측에서 도메인 객체의 변화를 감지하여 특정 코드를 실행하도록 만드는 기술이다.

## 이벤트 자동 퍼블리싱

스프링 데이터 Common은 save() 기능을 사용할 때 엔티티에 쌓여있던 이벤트를  자동으로 publishing하는 기능을 제공한다.

1. @DomainEvents
엔티티 이벤트를 모아두는 역할을 한다.
2.  @AfterDomainEventPublication
이벤트 컬렉션에 담겨있는 이벤트들을 발행한 뒤 이벤트 컬렉션을 비워주는 기능을 한다.

이것들은 직접 구현할 필요 없이 미리 구현되어있는 AbstractAggregationRoot\<E> 를 사용할 수 있다.

```java
public class AbstractAggregateRoot<A extends AbstractAggregateRoot<A>> {  
  
    private transient final @Transient List<Object> domainEvents = new ArrayList<>();  

	protected <T> T registerEvent(T event) {  
  
	    Assert.notNull(event, "Domain event must not be null");  
	  
	    this.domainEvents.add(event);  
	    return event;  
	}
  
	@AfterDomainEventPublication  
    protected void clearDomainEvents() {  
       this.domainEvents.clear();  
    }  
    
	@DomainEvents  
    protected Collection<Object> domainEvents() {  
       return Collections.unmodifiableList(domainEvents);  
    }
```

## 예제 
### 이벤트 정의
이는 POJO 로도 만들 수 있고, ApplicationEvent라는 스프링이 제공하는 클래스를 상속하여 만들수도 있다.
```java
public class PostPublishedEvent extends ApplicationEvent {  
  
    private final Post post;  
    public PostPublishedEvent(Object source) {  
        super(source);  
        this.post = (Post) source;  
    }  
  
    public Post getPost() {  
        return post;  
    }  
}
```

### 이벤트 리스너 생성

1. ApplicationListener를 활용하는 방법
```java
public class PostListener implements ApplicationListener<PostPublishedEvent> {  
	@Override  
	public void onApplicationEvent(PostPublishedEvent event) {  
		System.out.println("------------------");  
		System.out.println(event.getPost().getTitle() + " is published!!");  
		System.out.println("------------------");  
	}  
}
```
2. @EventListener를 사용하는 방법
```java
public class SimplePostListener {  
	@EventListener  
	public void onApplicationEvent(PostPublishedEvent event) {  
		System.out.println("------------------SimplePostListener");  
		System.out.println(event.getPost().getTitle() + " is published!!");  
		System.out.println("------------------");  
	}  
}
```

두 방법 모두 유효한 방법이고 모든 리스너들은 빈으로 등록되어야 한다.

### 도메인 클래스 수정
AbstractAggregationRoot의 registerEvent를 통해 발행하고자 하는 이벤트들을 생성한다.

AbstractAggregationRoot의 기능은 모두 protected로 작성되어있어서 외부에서 엔티티를 사용할 때 노출되지 않는다. 또한 이벤트 객체를 저장하는 컬렉션은 @Transient 애노테이션이 사용되어 매핑의 대상에서 제외된다.

```java
public class Post extends AbstractAggregateRoot<Post>{  
	...
  
    public Post publish() {  
        this.registerEvent(new PostPublishedEvent(this));  
        return this;  
    }  
}
```


이 작업을 거치면 postRepository.save()가 수행될 때 엔티티에 저장되어있던 이벤트 객체가 모두 발행된 후 지워진다. 이를 통해 행복 이벤트기반 프로그래밍을 할 수 있다.!

# Spring Data Common: Querydsl 연동

QuerydslPredicateExecutor 인터페이스
-> Optional\<T> findOne(Prdicate) : 조건을 통해 하나를 찾기
-> List\<T> findAll(Predicate) : 조건을 통해 여러개를 찾기


## 의존성 추가
Querydsl은 스프링부트가 버전을 관리해주므로 별도로 버전을 명시하지 않아도 된다.
```groovy
dependencies {  

	...
    implementation 'com.querydsl:querydsl-jpa'  
    implementation 'com.querydsl:querydsl-apt'  
}
```

querydsl-apt는 엔티티 모델을 분석하여 모델에 맞는 쿼리를 만들어주는 역할을 하는 라이브러리이다. 
이를 제대로 사용하기 위해서는 querydsl 플러그인 역시 설정해주어야 한다.

```groovy
plugins {  
	...
    id "com.ewerk.gradle.plugins.querydsl" version "1.0.10"  
}  
```

또한 여러 설정들을 제공해주어야 한다.
```groovy
buildscript {  
    ext {  
       queryDslVersion = "5.0.0"  
    }  
}  

def querydslDir = "$buildDir/generated/querydsl"  
  
querydsl {  
    jpa = true  
    querydslSourcesDir = querydslDir  
}  
  
sourceSets {  //자동 생성되는 클래스들을 어디에다가 넣을 것인가
    main.java.srcDir querydslDir  
}  
  
compileQuerydsl {  
    options.annotationProcessorPath = configurations.querydsl  
}  
  
configurations {  
    compileOnly {  
       extendsFrom annotationProcessor  
    }  
    querydsl.extendsFrom compileClasspath  
}
```

이렇게 작성을 한 뒤 gradle -> task -> other -> compileQuerydsl 을 실행하면 설정한 플러그인이 컴파일 phase와 함께 동작하면서 쿼리를 만들 수 있는 모듈을 생성한다.


Querydsl은 왤케 불편할까 Account 클래스 파일을 자꾸 못찾는 다는 오류가 나와서 일단 포기했다.


# 스프링 6, 스프링부트 3,  Java 17버전 이후 Querydsl 설정

java 17 부터는 자바의 패키지가 jakarta로 이동했으므로 이를 반영해준 라이브러리를 설치해야한다.
```groovy
dependencies {  
	...
    implementation "com.querydsl:querydsl-jpa:${queryDslVersion}:jakarta"  
    implementation "com.querydsl:querydsl-apt:${queryDslVersion}:jakarta"  
  
    annotationProcessor "jakarta.annotation:jakarta.annotation-api"  
    annotationProcessor "jakarta.persistence:jakarta.persistence-api"  
    annotationProcessor "com.querydsl:querydsl-apt:${dependencyManagement.importedProperties['querydsl.version']}:jakarta"  
}
```


```groovy
buildscript {  
    ext {  
       queryDslVersion = "5.0.0"  
    }  
}  
  
plugins {  
    id 'java'  
    id 'org.springframework.boot' version '2.7.15'  
    id 'io.spring.dependency-management' version '1.0.15.RELEASE'  
    id "com.ewerk.gradle.plugins.querydsl" version "1.0.10"  
}  
  
group = 'com.goorp'  
version = '0.0.1-SNAPSHOT'  
  
java {  
    sourceCompatibility = '17'  
}  
  
configurations {  
    compileOnly {  
       extendsFrom annotationProcessor  
    }  
}  
  
repositories {  
    mavenCentral()  
}  
  
dependencies {  
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'  
    implementation 'org.springframework.boot:spring-boot-starter-security'  
    implementation 'org.springframework.boot:spring-boot-starter-web'  
    implementation 'org.hibernate.validator:hibernate-validator'  
    implementation 'io.jsonwebtoken:jjwt-api:0.11.5'  
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.11.5'  
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.11.5'  
    implementation 'javax.xml.bind:jaxb-api:2.3.0'  
    compileOnly 'org.projectlombok:lombok'  
    annotationProcessor 'org.projectlombok:lombok'  
    testCompileOnly 'org.projectlombok:lombok'  
    testAnnotationProcessor 'org.projectlombok:lombok'  
  
    // db  
    runtimeOnly 'com.mysql:mysql-connector-j'  
    implementation 'com.h2database:h2'  
  
    // querydsl  
    implementation "com.querydsl:querydsl-jpa:${queryDslVersion}"  
    annotationProcessor "com.querydsl:querydsl-apt:${queryDslVersion}"  
  
    // 테스트 의존성  
    testRuntimeOnly 'com.h2database:h2'  
    testImplementation 'org.projectlombok:lombok:1.18.28'  
    testImplementation 'org.springframework.security:spring-security-test'  
    testImplementation 'org.springframework.boot:spring-boot-starter-test'  
    testImplementation 'org.springframework.security:spring-security-test:5.4.5'  
  
}  
  
tasks.named('test') {  
    useJUnitPlatform()  
}  
  
def querydslDir = "$buildDir/generated/querydsl"  
  
querydsl {  
    jpa = true  
    querydslSourcesDir = querydslDir  
}  
  
sourceSets {  
    main.java.srcDir querydslDir  
}  
  
compileQuerydsl {  
    options.annotationProcessorPath = configurations.querydsl  
}  
  
configurations {  
    compileOnly {  
       extendsFrom annotationProcessor  
    }  
    querydsl.extendsFrom compileClasspath  
}
```


# Spring Data Common: 웹 기능
아래 기능들은 @EnabldSpringDataWebSupport라는 애노테이션을 설정 클래스에 작성해줘야 동작하는 내용들이다. 스프링 부트는 이 애노테이션을 자동으로 등록해준다.

## 도메인 클래스 컨버터
```java
public class DomainClassConverter<T extends ConversionService & ConverterRegistry>  
       implements ConditionalGenericConverter, ApplicationContextAware { ...}
```
내부적으로는 크게 2가지 컨버터가 등록이 된다.
* ToEntityConverter : ID를 받아서 Entity 타입으로 변환하는 컨버터
* ToIdConverter : Entity 타입으로부터 ID를 가져오는 컨버터


## 예제
```java
@GetMapping("/posts/{id}")
public Post getPost(@PathVariable("id") Long id) {
	Post post = postRepository.findById(id).get();
	return post;
}
```
DomainClassConverter를 사용하면 PathVariable 등의 바인딩 애노테이션들을 사용하여 엔티티를 바로 받을 수 있다. 이 때 더 이상 변수명과 variable 명이 같지 않으므로 변수명을 필수로 입력해주어야 한다.
```java
@GetMapping("/posts/{id}")
public Post getPost(@PathVariable("id") Post post) {
	return post;
}
```



## @RequestHandler 메서드에서 Pageable과 Sort 매개변수 사용

## Page 관련 HATEOAS 기능 제공


## Payload Projection
@ProjectPayload 는 요청으로 들어오는 데이터 중 일부만 캡처해서 바인딩받을 수 있는 기능이다.
```java
@ProjectPayload
public interface UserPayload {
	@XBRead("//firstname")
	@JsonPath("$..firstname$")
	String getFirstname();
	
	@XBRead("//lastname")
	@JsonPath("$..lastname$")
	String getLastname()
}


...
@PostMapping
public void createUser(@RequestBody UserPayload user) {
	...
}
```

# Converter Interface

## Formatter와의 차이
Formatter은 무조건 시작 타입이 문자열이다. 문자열을 어떻게 바꿔줄 것이냐에 대한 책임을 갖는 기술