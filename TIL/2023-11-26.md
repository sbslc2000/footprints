
---
hello: 1

---

# 1일 1PS
 * 문제 이름 : 쿠키의 신체 측정
 * 링크 : https://www.acmicpc.net/problem/20125
 * 알고리즘 분류 : ?
 * 작성 일시 : 11-26

그냥 풀었다.

# Effective Java
하루 루틴으로 PS 1문제와 Effective Java 한 챕터를 읽어보려고 한다.

## 생성자 대신 정적 팩터리 메서드를 고려하라
### 장점
전통적으로 인스턴스를 생성하는 방법 대신 정적 팩터리 메서드를 사용한다면 다음과 같은 장점을 갖는다.
1. **이름을 가질 수 있다** : 생성자는 별도의 이름을 갖지 못하므로 정적 팩토리 메서드보다 표현할 수 있는 정보가 적다. 또한 하나의 시그니처에 대해 생성자는 하나만 만들 수 있지만, 정적 팩토리 메서드는 개수에 제한이 있지 않다.
2. **호출될 때 마다 인스턴스를 새로 생성하지는 않아도 된다** : 불변 클래스는 인스턴스를 미리 만들어 놓거나 만들었던 인스턴스를 캐싱하여 재활용하는 식으로 불필요한 객체 생성을 피할 수 있다. 이와 같은 방식으로 정적 팩토리 방식의 클래스는 언제 어느 인스턴스를 살아 있게 할지 통제할 수 있으며, 이런 클래스를 인스턴스 통제*instance-controlled* 클래스라고 한다. 싱글톤 패턴이나 인스턴스화 불가noninstantiable, 불변 값 클래스 등에서 사용했을때 효과적이다. -- *반면 생성자의 호출은 필연적으로 인스턴스를 만들어낸다.*
3. **반환 타입의 하위 타입 객체를 반환할 수 있다** : 이는 인터페이스를 정적 팩토리 메서드의 반환타입으로 사용하는 인터페이스 기반 프레임워크를 만드는 핵심 기술이기도 하다.
4. **입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다** : 정적 팩토리 내부 로직을 통해 해당 타입의 하위 타입 객체를 반환할 수 있기 때문에, 릴리즈를 거듭하면서 새로운 객체를 반환하거나 파라미터에 따라 서로 다른 객체를 반환하는 등 클라이언트 측에 영향을 주지 않으면서 개발이 수행될 수 있다.
5. **정적 팩토리 메서드를 작성하는 시점에 반환할 객체의 클래스가 존재하지 않아도 된다** : 이는 서비스 제공자 프레임워크를 만드는 근간이 된다. 클라이언트는 서비스 접근 API를 사용할 때 원하는 구현체의 조건을 명시할 수 있다. 서비스 인터페이스 없이도 정적 팩토리 메서드는 작성될 수 있으며 구현을 뒤로 미루거나 다른 이에게 위임할 수 있다.
### 단점

1. **상속에 대해서 제한이 생긴다**: 상속을 하려면 publicdlsk protected 생성자가 필요하니 정적 팩토리 메서드만으로는 하위 클래스를 만들 수 없다. 이를 문제는 상속 대신 Composition을 사용하는 방식으로 유도하여 해결할 수 있다.
2. **정적 팩토리 메서드는 프로그래머가 찾기 힘들다** : 생성자처럼 키워드에서 명시적으로 드러나지 않으니 이를 찾기 위해서는 API 문서를 확인해야할 것이다.

### 네이밍 관습

* **from** : 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드
```java
Date d = Date.from(instant);
```

* **of** : 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드
```java
Set<Rank> faceCards = Enumet.of(JACK, QUEEN, KING);
```

* **valueOf** : from과 of의 더 자세한 버전
```java
BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);
```

* **instance 또는 getInstance**: (매개변수를 받는다면) 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지는 않음
```java
StackWalker luke = StackWalker.getInstance(options);
```

* **create 혹은 newInstance** : instance 혹은 getInstance와 같지만, 매번 새로운 인스턴스를 생성해 반환함을 보장함
```java
Object newArray = Array.newInstance(classObject, arrayLen);
```

* **get\<Type>** : getInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다.
```java
FileStore fs = Files.getFileStore(path);
```

* **new\<Type>** : newInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다. 
```java
BufferedReader br = Files.newBufferedReader(path);
```

* **type** : getType과 newType의 간결한 버전

> [!info]
> 정적 팩토리 메서드와 public 생성자는 각자의 쓰임새가 있으니 상대적인 장단점을 이해하고 사용하는 것이 좋다. 그렇다 하더라도 정적 팩토리를 사용하는 게 유리한 경우가 더 많으므로 무작정 public 생성자를 제공하던 습관이 있다면 고치자.

### 함께보기
[서비스 제공자 프레임워크 service provider framework 이해하기](https://sihyung92.oopy.io/java/service-provider-framework)
