# COUNT(\*) vs COUNT(col)
![](https://i.imgur.com/172xWYb.png)
* NULLable 필드인 fd1에 대한 select 쿼리는 14107개를 반환한 것에 유의하라.
	* count 함수는 인자로 주어진 column의 null이 아닌 건 수를 반환했기 때문이다.
	* ix1 column 을 count한 것은 not null이기 때문에 같은 매커니즘으로 동작하더라도 count(\*)과 동일한 결과를 낸 것이다

![](https://i.imgur.com/DawjIsO.png)
* MySQL 문서에는 COUNT 함수는 null이 아닌 값들의 개수를 반환한다는 것을 확인할 수 있다.
	* 레코드 건 수가 아니다!
![](https://i.imgur.com/ADwalpK.png)
MySQL 서버는 InnoDB와 같은 스토리지 엔진이 다양한 기능을 API 형태로 제공하는 것을 사용하며, ha_records()나 ha_index_next()는 MySQL이 count 값을 제공하기 위해 사용하는 innoDB의 API이다.
where 조건이 없는 count Query는 특성에 따라서 큰 성능차이가 있음에도 불구하고 실행 계획에는 아무 차이가 없다. 주의할 필요가 있음.

![](https://i.imgur.com/SQyVyFN.png)
* 인덱스는 하나도 없고, fd1과 fd2(nullable)만 있는 상황이다. 
* 테이블에 실제 null데이터는 없다. 
* fd1, \* , fd2 에 대해 실행계획은 동일하지만, 시간 차이가 굉장히 난다.

![](https://i.imgur.com/VEntVG4.png)
* 내부적 차이를 살펴보기 위해 mysql 서버의 handler metric을 봐보자.
* count_fd1과 count_all 는 show status에서 handler 주요 메트릭에 변화가 없다.
* 반면 count_fd2는 Handler_read_rnd_next가 1000001임을 확인할 수 있다.
* 또한 Handler_read_first가 1인 것을 확인할 수 있는데, 이는 PK 인덱스를 풀스캔 했다는 의미이다.
* count_all은 왜 Handler_read_first가 0일까?
	* count_all은 InnoDB의 ha_records()를 통해 레코드 건수를 가져오기 때문에, handler 호출 횟수가 기록되지 않았다.   