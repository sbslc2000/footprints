# 풀스캔 쿼리 패턴 및 튜닝

## 컬럼이 가공되는 경우
![](https://i.imgur.com/p46353F.png)
컬럼이 가공되면 인덱스가 있더라도 쿼리가 인덱스를 사용하지 못한다. -> 인덱스가 컬럼의 원본 값을 기반으로 구성되어있기 때문에
- column에 대해 직접적으로 연산을 수행하거나
- 함수의 인자로 사용되거나
- type-conversion이 발생하거나

![](https://i.imgur.com/4tYIzeT.png)
![](https://i.imgur.com/UtRUYno.png) 
-> 함수를 제거하고, 범위조건을 사용하라
![](https://i.imgur.com/dR8lUPO.png)
문자열 타입인 account_type에 대해 숫자값 3을 줬더니 full-scan이 발생함. 실제 컬럼의 타입과 일치하는 타입으로 사용했을 때 정상적으로 인덱스를 사용함

반면 3번째는 예외케이스인데, 숫자타입인 인덱스에 문자타입으로 조건을 제공할 때는 인덱스를 사용한다. -> MySQL 내부 형변환 우선순위 : 문자가 숫자로 바뀌는 것을 더 우선순위로 따지기에, 조건을 숫자로 형변환하고, column의 형변환이 발생하지 않는다.

![](https://i.imgur.com/vKBjhfl.png)
account_type은 인덱스를 사용할 수 있지만, joined_at에는 인덱스가 없으므로 테이블 전체를 읽어야 한다. 
만약 joined_at에 대한 인덱스를 생성하면, 인덱스를 사용하는 것을 볼 수 있다.
OR 이 조건문에 있을 때는 이 부분에 유의하라

![](https://i.imgur.com/PaikTBV.png)
account_type과 joined_at이 복합 인덱스로 구성되어있을 때, joined_at만 조건에 들어있는 쿼리는 인덱스를 사용하지 못한다.
인덱스를 구성하는 컬럼들의 순서가, 쿼리에서 인덱스 사용 여부를 결정하는데 중요하다. -> **후행 컬럼이 누락되었을 때는 인덱스를 사용한다**.

![](https://i.imgur.com/yROiHP2.png)
와일드카드가 뒤에 있는 것은 상관 없다.

![](https://i.imgur.com/xWyU3ld.png)
정규표현식을 조건으로 하여 조회하는 것은 정규표현식에 맞는 값을 찾기 위해 하나하나 검사해야하기 때문이다.

![](https://i.imgur.com/2WnPvji.png)
A B가 대부분인 경우, 인덱스 페이지의 거의 대부분을 읽고, 그 이후 조건 검사를 통해 테이블 페이지의 거의 대부분을 읽게 된다. 이런 경우 차라리 처음부터 테이블 페이지를 full-scan하는 것이 빠르다. 이러한 판단은 MySQL이 알아서 최적화해주는 부분이다.
한 편 C와 D에 대해서는 인덱스를 사용하는 것이 빠를테므로 실행계획이 인덱스를 사용하도록 만들어졌다.


![](https://i.imgur.com/F1yUvm2.png)
1. 조건에 해당하는 데이터가 소수이기 때문에 인덱스를 사용하는 실행계획이 수립되었다.
2. 1의 반대


NOT Equal, IS NOT NULL은 상황에 따라 인덱스를 사용하며, 데이터 분포에 따라서 실행계획이 달라질 수 있다.


![](https://i.imgur.com/XYw1AOd.png)
