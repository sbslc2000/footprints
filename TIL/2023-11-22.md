# 1일1PS
 * 문제 이름 : 비밀번호 발음하기
 * 링크 : https://www.acmicpc.net/problem/4659
 * 풀이: [1122 · sbslc2000/MyPsChallenge@4609fd8 · GitHub](https://github.com/sbslc2000/MyPsChallenge/commit/4609fd899d1c31d3e485887528aa2bbc885ebfa2)
 * 알고리즘 분류 : ?
 * 작성 일시 : 2023-11-22
 * 관련 링크 :
 * 메모리 제한 :  128 MB
 * 시간 제한 : 1초
 * 문자열을 한 번 스캔하면서 품질을 평가할 수 있을 것 같다.

# 9oorp Exception 구조화
[#80 exception구조화 by sbslc2000 · Pull Request #82 · 9oorp/backend · GitHub](https://github.com/9oorp/backend/pull/82)

# 스프링 데이터 쿼리 만들기 
## IgnoreCase
메서드 이름에 IgnoreCase를 작성하면 SQL문에 upper()가 추가되어 대,소문자 구분없이 문자열을 검색할 수 있다.
```java
Optional<Member> goorm = memberRepository.findByNameContainsIgnoreCase("Goorm"); 
assertThat(goorm).isPresent();

//Hibernate: select m1_0.id,case when m1_1.id is not null then 1 when m1_0.id is not null then 0 end,m1_0.age,m1_0.name,m1_1.customer_name from member m1_0 left join customer m1_1 on m1_0.id=m1_1.id where upper(m1_0.name) like upper(?) escape '\'
```

## Stream
메서드의 반환타입으로 Stream을 사용할 수 있다. Stream은 사용한 뒤 close()가 필요하므로 try-with-resource문을 사용하는 것이 권장된다.
```java
try(Stream<Member> members = memberRepository.findByOrderByNameDesc()) {        assertThat(members.findFirst().get()).hasFieldOrPropertyWithValue("name","ZZZ"); 
}
```

## 비동기 쿼리 
@Async를 사용하면 메서드의 실행을 별도의 쓰레드에 위임할 수 있다. 이를 사용하기 위해서는 @EnableAsync 애노테이션을 설정 클래스에 부착해줄 수 있다.

non-blocking 방식으로 동작하게 만들려면 Future를 사용해야한다.
```java
@Async  
Future<List<Member>> findByOrderByNameDesc();
```

Future와 관련된 클래스도 Future, CompletableFuture, ListenableFuture 등이 있는데 스프링에서 지원하는 ListenableFuture을 사용할 것을 권장한다. 근데 ListenableFuture은 Deprecated 되었다. 대신 CompletableFuture을 사용하는 것이 좋을 것 같다.

Future API는 콜백을 지원하지 않는다. 따라서 비동기적인 코드를 작성하기 어려울 수 있다. 반면 ListenableFuture은 콜백 기능을 사용한다.

하지만 비동기 쿼리는 테스트하기에 어렵다.
1. 콜백 메서드는 별도의 쓰레드에서 수행되므로 로그가 찍히지 않는다. 실질적으로 해당 테스트메서드에 없는 코드나 마찬가지이다. 
2. 비동기 쿼리는 트랜잭션 전파의 영향을 받지만, 새롭게 생긴 쓰레드는 기존 쓰레드의 트랜잭션에서 변경된 변화를 감지하지 못하고 트랜잭션 이전 상태의 데이터를 쿼리한다.

-> 동기적으로 작성하자! 비동기로 얻을 수 있는 성능 튜닝은 미미하다. 

# Custom Repository
쿼리 메서드로 해결이 되지 않는 경우 직접 코딩으로 구현 가능하다.


스프링 데이터 레포지토리 인터페이스에 기능을 추가할 수 있으며, 기본 기능을 덮어쓰기하는 것도 가능하다.
