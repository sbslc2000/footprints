# 1일1PS
문제 : 줄 세우기
문제 링크 : [10431번: 줄세우기](https://www.acmicpc.net/problem/10431)
링크 : [1120 · sbslc2000/MyPsChallenge@132bccc · GitHub](https://github.com/sbslc2000/MyPsChallenge/commit/132bccc8c22440198663f9ccfc06e2273b4be30f)

# gradle에서 변수 설정
ext로 설정한 변수를 가져올 때에는 따옴표가 아닌 쌍따옴표에 값을 넣어줘야 하는 것 같다.

```groovy
implementation "com.querydsl:querydsl-jpa:${queryDslVersion}"  
annotationProcessor "com.querydsl:querydsl-apt:${queryDslVersion}"

implementation 'com.querydsl:querydsl-jpa:${queryDslVersion}' //이건 안됨
```

# QueryDsl 연동
[[Spring] QueryDSL 완벽 이해하기](https://velog.io/@jkijki12/Spring-QueryDSL-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)


# BufferedReader와 BufferedWriter
버퍼를 사용하면 왜 빠른가?

## BufferedReader

### 한 줄 가져오기
```java
BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
String s = bf.readLine();
int i = Integer.parseInt(bf.readLine());
```

### 공백단위로 데이터 가공하기
```java
String s = bf.readLine();
StringTokenizer st = new StringTokenizer(s);
int a = Integer.parseInt(st.nextToken());
int b = Integer.parseInt(st.nextToken());

String array[] = s.split(" ");
```

## BufferedWriter
```java
BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
String s = "abcdefg";
bw.write(s+"\n");
bw.flush();
bw.close();
```

# 트랜잭션 전파
트랜잭션이 중첩되는 경우 어떻게 동작해야하나?
## 트랜잭션의 중첩
하나의 트랜잭션이 시작되고 끝나기 전에 새로운 트랜잭션 단위가 생길 수 있다. 이 때 새로 생긴 트랜잭션을 내부 트랜잭션, 기존에 수행되던 트랜잭션을 외부 트랜잭션이라고 한다.
내부 트랜잭션이 커밋 혹은 롤백 되었을 때 외부 트랜잭션이 어떻게 행동해야할 지 결정하는 것을 트랜잭션 전파라고 한다.
![](https://i.imgur.com/dUFAECH.png)

외부 트랜잭션이 아직 commit되지 않았는데 새로운 트랜잭션이 생성되는 경우 스프링은 기본적으로 두 트랜잭션을 묶어서 하나의 트랜잭션을 만든다.
![](https://i.imgur.com/k7hAe2L.png)

## 물리 트랜잭션,  논리 트랜잭션
![](https://i.imgur.com/I15XslU.png)

스프링은 트랜잭션 전파 정책을 설명하기 위해 물리 트랜잭션과 논리 트랜잭션이라는 개념을 사용한다.
물리 트랜잭션이란 실제 데이터베이스에 적용되는 트랜잭션이며, 논리 트랜잭션은 트랜잭션 매니저를 통해 트랜잭션을 사용하는 단위이다. 이러한 개념은 트랜잭션이 중첩된 경우에만 나타난다.

이를 통해 스프링은 단순한 트랜잭션의 중첩에 대해 다음과 같은 원칙을 적용할 수 있다.
* **모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋된다.**
* **하나의 논리 트랜잭션이라도 롤백되면 물리 트랜잭션은 롤백된다.**